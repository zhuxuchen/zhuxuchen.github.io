<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>流年苦忆往昔的博客</title>
  
  
  <link href="https://zhuxuchen.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhuxuchen.github.io/"/>
  <updated>2023-05-20T13:26:39.742Z</updated>
  <id>https://zhuxuchen.github.io/</id>
  
  <author>
    <name>流年苦忆往昔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实习报告</title>
    <link href="https://zhuxuchen.github.io/2023-05-20-fa4c9ac1ee33/"/>
    <id>https://zhuxuchen.github.io/2023-05-20-fa4c9ac1ee33/</id>
    <published>2023-05-20T13:18:40.000Z</published>
    <updated>2023-05-20T13:26:39.742Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文使用AI辅助写作，以下为正文内容</p></blockquote><p>​本人于2023年3月至2023年6月期间，在一家计算机系统公司进行了为期三个月的实习。本次实习主要负责使用SSM框架开发维护工程制造相关的Java Web项目，主要技术栈有EasyUi，JQuery，Java，SQLServer，Mybatis等。主要负责了人员维护，人员排班，人员考勤，奖金发放与维护，物料管理等模块的开发与维护。</p><h3 id="一、实习基本情况"><a href="#一、实习基本情况" class="headerlink" title="一、实习基本情况"></a>一、实习基本情况</h3><p>​在实习期间，我主要参与了公司内部的Java Web项目的开发和维护工作。在这个过程中，我学习了很多关于Java Web开发的知识和技能，并且了解了企业级应用的开发流程和规范。同时，我也参与了项目的需求分析、数据库设计、编码和测试等工作。</p><h3 id="二、实习内容"><a href="#二、实习内容" class="headerlink" title="二、实习内容"></a>二、实习内容</h3><p>​实习内容主要包括技术栈的学习与项目的开发，以下将从这两方面分别阐述。</p><h4 id="1）技术栈学习"><a href="#1）技术栈学习" class="headerlink" title="1）技术栈学习"></a>1）技术栈学习</h4><ol><li>EasyUi和JQuery的使用</li></ol><p>​    在开发前端页面时，我主要使用了EasyUi和JQuery这两个前端框架。EasyUi是一个基于jQuery的UI库，提供了丰富的UI组件和交互效果，可以快速构建出美观、易用的前端页面。在实践中，我学习了EasyUi的各种组件的使用方法，包括表格、表单、对话框、树形菜单等。同时，我也学习了JQuery的基本语法和常用方法，掌握了如何使用JQuery来操作DOM元素、处理事件等。</p><ol start="2"><li>SQLServer和Mybatis的使用</li></ol><p>​    在开发后台逻辑时，我主要使用了SQLServer数据库和Mybatis框架。SQLServer是一种关系型数据库管理系统，可以存储和管理各种数据。在实践中，我学习了SQLServer的基本语法和常用操作，包括创建表、插入数据、查询数据等。同时，我也学习了Mybatis框架的使用方法，掌握了如何使用Mybatis来进行数据库操作，包括增删改查等。</p><ol start="3"><li>Java的使用</li></ol><p>​    在开发后台逻辑时，我主要使用了Java语言。Java是一种面向对象的编程语言，具有跨平台性和安全性等优点。在实践中，我学习了Java的基本语法和面向对象编程的思想，掌握了如何使用Java来编写后台逻辑代码。</p><h4 id="2）项目开发"><a href="#2）项目开发" class="headerlink" title="2）项目开发"></a>2）项目开发</h4><ol><li>人员维护模块</li></ol><p>​    人员维护模块是一个比较基础的模块，主要是对公司员工的基本信息进行维护。在这个模块中，我主要负责了员工信息的录入和查询功能的实现。通过这个模块的开发，我了解了如何使用EasyUi和JQuery框架来实现一个简单的数据表格，并且学习了如何使用Mybatis框架来操作数据库。</p><ol start="2"><li>人员排班模块</li></ol><p>​    人员排班模块是一个比较复杂的模块，主要是对公司员工的排班进行管理。在这个模块中，我主要负责了排班计划的制定和员工排班的查询功能的实现。由于数据库分表的原因，人员排班模块需要进行多表查询，这无疑加大了查询的难度，也是对我SQL功底的考验。通过这个模块的开发，我了解了如何使用EasyUi和JQuery框架来实现一个日历控件，并且学习了如何使用SQLServer数据库来存储和查询排班计划。</p><ol start="3"><li>人员考勤模块</li></ol><p>​    人员考勤模块是一个比较重要的模块，主要是对公司员工的考勤情况进行管理。在这个模块中，我主要负责了考勤记录的录入和查询功能的实现。通过这个模块的开发，我了解了如何使用EasyUi和JQuery框架来实现一个日期选择器，如何对下拉框进行联动等前端功能，并且学习了如何使用Java语言来实现业务逻辑。</p><ol start="4"><li>奖金发放与维护模块</li></ol><p>​    奖金发放与维护模块是一个比较特殊的模块，主要是对公司员工的奖金进行管理。在这个模块中，我主要负责了奖金记录的录入和查询功能的实现。通过这个模块的开发，我了解了如何使用EasyUi和JQuery框架来实现一个弹出框，并且学习了如何使用SQLServer数据库来存储和查询奖金记录。</p><ol start="5"><li>物料管理模块</li></ol><p>​    物料管理模块是一个比较复杂的模块，主要是对公司物料的管理。在这个模块中，我主要负责了物料信息的录入和查询功能的实现。通过这个模块的开发，我了解了如何使用EasyUi和JQuery框架来实现一个树形控件，并且学习了如何使用Mybatis框架来操作数据库。</p><h3 id="三、思想和专业知识和技能的收获与体会"><a href="#三、思想和专业知识和技能的收获与体会" class="headerlink" title="三、思想和专业知识和技能的收获与体会"></a>三、思想和专业知识和技能的收获与体会</h3><p>​    在实习期间，我不仅学习了各种技术栈的使用方法，还提升了自己的思想和专业知识和技能。具体来说，我收获了以下几点：</p><ol><li>学会了如何快速学习新技术</li></ol><p>​    在实习期间，我接触了很多新的技术和工具，包括EasyUi、JQuery、SQLServer、Mybatis等。这些技术和工具都是我之前没有接触过的，但是我通过查阅官方文档、参考书籍和网上教程等途径，很快就掌握了它们的使用方法。通过这个过程，我学会了如何快速学习新技术，这对我以后的学习和工作都非常有帮助。</p><ol start="2"><li>加强了团队协作能力</li></ol><p>​    在实习期间，我和其他实习生一起参与了项目的开发和维护工作。在这个过程中，我们需要相互协作，共同完成任务。通过这个过程，我加强了自己的团队协作能力，学会了如何与他人合作，如何分工合作，如何沟通协调等。</p><ol start="3"><li>提升了编程能力</li></ol><p>​    在实习期间，我不断地编写代码，不断地调试和优化代码。通过这个过程，我提升了自己的编程能力，学会了如何编写高质量的代码，如何调试和优化代码，如何处理各种异常情况等。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>​在实习期间，我不仅学习了很多关于Java Web开发的知识和技能，还了解了企业级应用的开发流程和规范。通过参与项目的需求分析、数据库设计、编码和测试等工作，我也提高了自己的沟通能力和团队合作能力。同时，我还意识到了自己在知识和技能方面的不足之处，这也激励我在未来的学习中更加努力。</p><p>​总之，这次实习让我受益匪浅。通过参与实际项目的开发和维护工作，我不仅学习了很多关于Java Web开发的知识和技能，还提高了自己的沟通能力和团队合作能力。我相信这些经验和收获将会对我未来的职业发展产生积极的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文使用AI辅助写作，以下为正文内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​	本人于2023年3月至2023年6月期间，在一家计算机系统公司进行了为期三个月的实习。本次实习主要负责使用SSM框架开发维护工程制造相关的Java Web项目，主要</summary>
      
    
    
    
    <category term="随笔" scheme="https://zhuxuchen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="Java" scheme="https://zhuxuchen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机篇</title>
    <link href="https://zhuxuchen.github.io/2023-03-05-ffa683208bec/"/>
    <id>https://zhuxuchen.github.io/2023-03-05-ffa683208bec/</id>
    <published>2023-03-05T09:15:00.000Z</published>
    <updated>2023-03-05T09:21:18.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机篇"><a href="#虚拟机篇" class="headerlink" title="虚拟机篇"></a>虚拟机篇</h1><h2 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1. JVM 内存结构"></a>1. JVM 内存结构</h2><p><strong>要求</strong></p><ul><li>掌握 JVM 内存结构划分</li><li>尤其要知道方法区、永久代、元空间的关系</li></ul><p><strong>结合一段 java 代码的执行理解内存划分</strong></p><p><img src="/2023-03-05-ffa683208bec/image-20210831165728217.png" alt="image-20210831165728217"></p><ul><li>执行 javac 命令编译源代码为字节码</li><li>执行 java 命令<ol><li>创建 JVM，调用类加载子系统加载 class，将类的信息存入<strong>方法区</strong></li><li>创建 main 线程，使用的内存区域是 <strong>JVM 虚拟机栈</strong>，开始执行 main 方法代码</li><li>如果遇到了未见过的类，会继续触发类加载过程，同样会存入<strong>方法区</strong></li><li>需要创建对象，会使用<strong>堆</strong>内存来存储对象</li><li>不再使用的对象，会由<strong>垃圾回收器</strong>在内存不足时回收其内存</li><li>调用方法时，方法内的局部变量、方法参数所使用的是  <strong>JVM 虚拟机栈</strong>中的栈帧内存</li><li>调用方法时，先要到<strong>方法区</strong>获得到该方法的字节码指令，由<strong>解释器</strong>将字节码指令解释为机器码执行</li><li>调用方法时，会将要执行的指令行号读到<strong>程序计数器</strong>，这样当发生了线程切换，恢复时就可以从中断的位置继续</li><li>对于非 java 实现的方法调用，使用内存称为<strong>本地方法栈</strong>（见说明）</li><li>对于热点方法调用，或者频繁的循环代码，由 <strong>JIT 即时编译器</strong>将这些代码编译成机器码缓存，提高执行性能</li></ol></li></ul><p>说明</p><ul><li>加粗字体代表了 JVM 虚拟机组件</li><li>对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</li></ul><p><strong>会发生内存溢出的区域</strong></p><ul><li>不会出现内存溢出的区域 – 程序计数器</li><li>出现 OutOfMemoryError 的情况<ul><li>堆内存耗尽 – 对象越来越多，又一直在使用，不能被垃圾回收</li><li>方法区内存耗尽 – 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li><li>虚拟机栈累积 – 每个线程最多会占用 1 M 内存，线程个数越来越多，而又长时间运行不销毁时</li></ul></li><li>出现 StackOverflowError 的区域<ul><li>JVM 虚拟机栈，原因有方法递归调用未正确结束、反序列化 json 时循环引用</li></ul></li></ul><p><strong>方法区、永久代、元空间</strong></p><ul><li><strong>方法区</strong>是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等</li><li><strong>永久代</strong>是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li><li><strong>元空间</strong>是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li></ul><p><img src="/2023-03-05-ffa683208bec/image-20210831170457337.png" alt="image-20210831170457337"></p><p>从这张图学到三点</p><ul><li>当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间</li><li>X，Y 的类元信息是存储于元空间中，无法直接访问</li><li>可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用</li></ul><p><img src="/2023-03-05-ffa683208bec/image-20210831170512418.png" alt="image-20210831170512418"></p><p>从这张图可以学到</p><ul><li>堆内存中：当一个<strong>类加载器对象</strong>，这个类加载器对象加载的所有<strong>类对象</strong>，这些类对象对应的所有<strong>实例对象</strong>都没人引用时，GC 时就会对它们占用的对内存进行释放</li><li>元空间中：内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放</li></ul><h2 id="2-JVM-内存参数"><a href="#2-JVM-内存参数" class="headerlink" title="2. JVM 内存参数"></a>2. JVM 内存参数</h2><p><strong>要求</strong> </p><ul><li>熟悉常见的 JVM 参数，尤其和大小相关的</li></ul><p><strong>堆内存，按大小设置</strong></p><p><img src="/2023-03-05-ffa683208bec/image-20210831173130717.png" alt="image-20210831173130717"></p><p>解释：</p><ul><li>-Xms 最小堆内存（包括新生代和老年代）</li><li>-Xmx 最大对内存（包括新生代和老年代）</li><li>通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li><li>-XX:NewSize 与 -XX:MaxNewSize 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制</li><li>-Xmn 设置新生代大小，相当于同时设置了 -XX:NewSize 与 -XX:MaxNewSize 并且取值相等</li><li>保留是指，一开始不会占用那么多内存，随着使用内存越来越多，会逐步使用这部分保留内存。下同</li></ul><p><strong>堆内存，按比例设置</strong></p><p><img src="/2023-03-05-ffa683208bec/image-20210831173045700.png" alt="image-20210831173045700"></p><p>解释：</p><ul><li>-XX:NewRatio&#x3D;2:1 表示老年代占两份，新生代占一份</li><li>-XX:SurvivorRatio&#x3D;4:1 表示新生代分成六份，伊甸园占四份，from 和 to 各占一份</li></ul><p><strong>元空间内存设置</strong></p><p><img src="/2023-03-05-ffa683208bec/image-20210831173118634.png" alt="image-20210831173118634"></p><p>解释：</p><ul><li>class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制</li><li>non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）</li><li>class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制</li></ul><p>注意：</p><ul><li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启</li></ul><p><strong>代码缓存内存设置</strong></p><p><img src="/2023-03-05-ffa683208bec/image-20210831173148816.png" alt="image-20210831173148816"></p><p>解释：</p><ul><li>如果 -XX:ReservedCodeCacheSize &lt; 240m，所有优化机器代码不加区分存在一起</li><li>否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e）<ul><li>non-nmethods - JVM 自己用的代码</li><li>profiled nmethods - 部分优化的机器码</li><li>non-profiled nmethods - 完全优化的机器码</li></ul></li></ul><p><strong>线程内存设置</strong></p><p><img src="/2023-03-05-ffa683208bec/image-20210831173155481.png" alt="image-20210831173155481"></p><blockquote><p><em><strong>官方参考文档</strong></em></p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></li></ul></blockquote><h2 id="3-JVM-垃圾回收"><a href="#3-JVM-垃圾回收" class="headerlink" title="3. JVM 垃圾回收"></a>3. JVM 垃圾回收</h2><p><strong>要求</strong></p><ul><li>掌握垃圾回收算法</li><li>掌握分代回收思想</li><li>理解三色标记及漏标处理</li><li>了解常见垃圾回收器</li></ul><p><strong>三种垃圾回收算法</strong></p><p>标记清除法</p><p><img src="/2023-03-05-ffa683208bec/image-20210831211008162.png" alt="image-20210831211008162"></p><p>解释：</p><ol><li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li><li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li><li>清除阶段：释放未加标记的对象占用的内存</li></ol><p>要点：</p><ul><li>标记速度与存活对象线性关系</li><li>清除速度与内存大小线性关系</li><li>缺点是会产生内存碎片</li></ul><p>标记整理法</p><p><img src="/2023-03-05-ffa683208bec/image-20210831211641241.png" alt="image-20210831211641241"></p><p>解释：</p><ol><li>前面的标记阶段、清理阶段与标记清除法类似</li><li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li></ol><p>特点：</p><ul><li><p>标记速度与存活对象线性关系</p></li><li><p>清除与整理速度与内存大小成线性关系</p></li><li><p>缺点是性能上较慢</p></li></ul><p>标记复制法</p><p><img src="/2023-03-05-ffa683208bec/image-20210831212125813.png" alt="image-20210831212125813"></p><p>解释：</p><ol><li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li><li>标记阶段与前面的算法类似</li><li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li><li>复制完成后，交换 from 和 to 的位置即可</li></ol><p>特点：</p><ul><li>标记与复制速度与存活对象成线性关系</li><li>缺点是会占用成倍的空间</li></ul><p><strong>GC 与分代回收算法</strong></p><p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p><p>GC 要点：</p><ul><li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li><li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li><li>GC 具体的实现称为<strong>垃圾回收器</strong></li><li>GC 大都采用了<strong>分代回收思想</strong><ul><li>理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li><li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用标记复制法、老年代一般采用标记整理法</li></ul></li><li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></li></ul><p><strong>分代回收</strong></p><ol><li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210831213622704.png" alt="image-20210831213622704"></p><ol start="2"><li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210831213640110.png" alt="image-20210831213640110"></p><ol start="3"><li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210831213657861.png" alt="image-20210831213657861"></p><ol start="4"><li>将 from 和 to 交换位置</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210831213708776.png" alt="image-20210831213708776"></p><ol start="5"><li>经过一段时间后伊甸园的内存又出现不足</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210831213724858.png" alt="image-20210831213724858"></p><ol start="6"><li>标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210831213737669.png" alt="image-20210831213737669"></p><ol start="7"><li>将存活对象采用复制算法复制到 to 中</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210831213804315.png" alt="image-20210831213804315"></p><ol start="8"><li>复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210831213815371.png" alt="image-20210831213815371"></p><ol start="9"><li>将 from 和 to 交换位置</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210831213826017.png" alt="image-20210831213826017"></p><ol start="10"><li>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ol><p><strong>GC 规模</strong></p><ul><li><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p></li><li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p></li><li><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p></li></ul><p><strong>三色标记</strong></p><p>即用三种颜色记录对象的标记状态</p><ul><li>黑色 – 已标记</li><li>灰色 – 标记中</li><li>白色 – 还未标记</li></ul><ol><li>起始的三个对象还未处理完成，用灰色表示</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;"><ol start="2"><li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;"><ol start="3"><li>依次类推</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;"><ol start="4"><li>沿着引用链都标记了一遍</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;"><ol start="5"><li>最后为标记的白色对象，即为垃圾</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;"><p><strong>并发漏标问题</strong></p><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p><ol><li>如图所示标记工作尚未完成</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831215846876.png" alt="image-20210831215846876" style="zoom:50%;"><ol start="2"><li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831215904073.png" alt="image-20210831215904073" style="zoom:50%;"><ol start="3"><li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831215919493.png" alt="image-20210831215919493" style="zoom:50%;"><ol start="4"><li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831220004062.png" alt="image-20210831220004062" style="zoom:50%;"><p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p><ol><li>Incremental Update 增量更新法，CMS 垃圾回收器采用<ul><li>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li></ul></li><li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用<ul><li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li><li>新加对象会被记录</li><li>被删除引用关系的对象也被记录</li></ul></li></ol><p><strong>垃圾回收器 - Parallel GC</strong></p><ul><li><p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p></li><li><p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p></li><li><p><strong>注重吞吐量</strong></p></li></ul><p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p><ul><li><p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法</p><ul><li>并发标记时不需暂停用户线程</li><li>重新标记时仍需暂停用户线程</li></ul></li><li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p></li><li><p><strong>注重响应时间</strong></p></li></ul><p><strong>垃圾回收器 - G1 GC</strong></p><ul><li><strong>响应时间与吞吐量兼顾</strong></li><li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>分成三个阶段：新生代回收、并发标记、混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><p><strong>G1 回收阶段 - 新生代回收</strong></p><ol><li>初始时，所有区域都处于空闲状态</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222639754.png" alt="image-20210831222639754" style="zoom:50%;"><ol start="2"><li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222653802.png" alt="image-20210831222653802" style="zoom:50%;"><ol start="3"><li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222705814.png" alt="image-20210831222705814" style="zoom:50%;"><ol start="4"><li>复制完成，将之前的伊甸园内存释放</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222724999.png" alt="image-20210831222724999" style="zoom:50%;"><ol start="5"><li>随着时间流逝，伊甸园的内存又有不足</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222737928.png" alt="image-20210831222737928" style="zoom:50%;"><ol start="6"><li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222752787.png" alt="image-20210831222752787" style="zoom:50%;"><ol start="7"><li>释放伊甸园以及之前幸存区的内存</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222803281.png" alt="image-20210831222803281" style="zoom:50%;"><p><strong>G1 回收阶段 - 并发标记与混合收集</strong></p><ol><li>当老年代占用内存超过阈值后，触发并发标记，这时无需暂停用户线程</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222813959.png" alt="image-20210831222813959" style="zoom:50%;"><ol start="2"><li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222828104.png" alt="image-20210831222828104" style="zoom:50%;"><ol start="3"><li>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222841096.png" alt="image-20210831222841096" style="zoom:50%;"><ol start="4"><li>下图显示了老年代和幸存区晋升的存活对象的复制</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222859760.png" alt="image-20210831222859760" style="zoom:50%;"><ol start="5"><li>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</li></ol><img src="/2023-03-05-ffa683208bec/image-20210831222919182.png" alt="image-20210831222919182" style="zoom:50%;"><h2 id="4-内存溢出"><a href="#4-内存溢出" class="headerlink" title="4. 内存溢出"></a>4. 内存溢出</h2><p><strong>要求</strong></p><ul><li>能够说出几种典型的导致内存溢出的情况</li></ul><p><strong>典型情况</strong></p><ul><li>误用线程池导致的内存溢出<ul><li>参考 day03.TestOomThreadPool</li></ul></li><li>查询数据量太大导致的内存溢出<ul><li>参考 day03.TestOomTooManyObject</li></ul></li><li>动态生成类导致的内存溢出<ul><li>参考 day03.TestOomTooManyClass</li></ul></li></ul><h2 id="5-类加载"><a href="#5-类加载" class="headerlink" title="5. 类加载"></a>5. 类加载</h2><p><strong>要求</strong></p><ul><li>掌握类加载阶段</li><li>掌握类加载器</li><li>理解双亲委派机制</li></ul><p><strong>类加载过程的三个阶段</strong></p><ol><li><p>加载</p><ol><li><p>将类的字节码载入方法区，并创建类.class 对象</p></li><li><p>如果此类的父类没有加载，先加载父类</p></li><li><p>加载是懒惰执行</p></li></ol></li><li><p>链接</p><ol><li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li><li>准备 – 为 static 变量分配空间，设置默认值</li><li>解析 – 将常量池的符号引用解析为直接引用</li></ol></li><li><p>初始化</p><ol><li>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</li><li>static final 修饰的基本类型变量赋值，在链接阶段就已完成</li><li>初始化是懒惰执行</li></ol></li></ol><blockquote><p><em><strong>验证手段</strong></em></p><ul><li>使用 jps 查看进程号</li><li>使用 jhsdb 调试，执行命令 <code>jhsdb.exe hsdb</code> 打开它的图形界面<ul><li>Class Browser 可以查看当前 jvm 中加载了哪些类</li><li>控制台的 universe 命令查看堆内存范围</li><li>控制台的 g1regiondetails 命令查看 region 详情</li><li><code>scanoops 起始地址 结束地址 对象类型</code> 可以根据类型查找某个区间内的对象地址</li><li>控制台的 <code>inspect 地址</code> 指令能够查看这个地址对应的对象详情</li></ul></li><li>使用 javap 命令可以查看 class 字节码</li></ul></blockquote><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestLazy - 验证类的加载是懒惰的，用到时才触发类加载</li><li>day03.loader.TestFinal - 验证使用 final 修饰的变量不会触发类加载</li></ul></blockquote><p><strong>jdk 8 的类加载器</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>加载哪的类</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为 Bootstrap，显示为  null</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>上级为 Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为 Application</td></tr></tbody></table><p><strong>双亲委派机制</strong></p><p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p><ul><li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li><li>找不到这个类，则下级类加载器才有资格执行加载</li></ul><p>双亲委派的目的有两点</p><ol><li><p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</p></li><li><p>让类的加载有优先次序，保证核心类优先加载</p></li></ol><p><strong>对双亲委派的误解</strong></p><p>下面面试题的回答是错误的</p><p><img src="/2023-03-05-ffa683208bec/image-20210901110910016.png" alt="image-20210901110910016"></p><p>错在哪了？</p><ul><li><p>自己编写类加载器就能加载一个假冒的 java.lang.System 吗? 答案是不行。</p></li><li><p>假设你自己的类加载器用双亲委派，那么优先由启动类加载器加载真正的 java.lang.System，自然不会加载假冒的</p></li><li><p>假设你自己的类加载器不用双亲委派，那么你的类加载器加载假冒的 java.lang.System 时，它需要先加载父类 java.lang.Object，而你没有用委派，找不到 java.lang.Object 所以加载会失败</p></li><li><p><strong>以上也仅仅是假设</strong>。事实上操作你就会发现，自定义类加载器加载以 java. 打头的类时，会抛安全异常，在 jdk9 以上版本这些特殊包名都与模块进行了绑定，更连编译都过不了</p></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestJdk9ClassLoader - 演示类加载器与模块的绑定关系</li></ul></blockquote><h2 id="6-四种引用"><a href="#6-四种引用" class="headerlink" title="6. 四种引用"></a>6. 四种引用</h2><p><strong>要求</strong></p><ul><li>掌握四种引用</li></ul><p><strong>强引用</strong></p><ol><li><p>普通变量赋值即为强引用，如 A a &#x3D; new A();</p></li><li><p>通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收</p></li></ol><img src="/2023-03-05-ffa683208bec/image-20210901111903574.png" alt="image-20210901111903574" style="zoom:80%;"><p><strong>软引用（SoftReference）</strong></p><ol><li><p>例如：SoftReference a &#x3D; new SoftReference(new A());</p></li><li><p>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象</p></li><li><p>软引用自身需要配合引用队列来释放</p></li><li><p>典型例子是反射数据</p></li></ol><img src="/2023-03-05-ffa683208bec/image-20210901111957328.png" alt="image-20210901111957328" style="zoom:80%;"><p><strong>弱引用（WeakReference）</strong></p><ol><li><p>例如：WeakReference a &#x3D; new WeakReference(new A());</p></li><li><p>如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象</p></li><li><p>弱引用自身需要配合引用队列来释放</p></li><li><p>典型例子是 ThreadLocalMap 中的 Entry 对象</p></li></ol><img src="/2023-03-05-ffa683208bec/image-20210901112107707.png" alt="image-20210901112107707" style="zoom:80%;"><p><strong>虚引用（PhantomReference）</strong></p><ol><li><p>例如： PhantomReference a &#x3D; new PhantomReference(new A(), referenceQueue);</p></li><li><p>必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理</p></li><li><p>典型例子是 Cleaner 释放 DirectByteBuffer 关联的直接内存</p></li></ol><img src="/2023-03-05-ffa683208bec/image-20210901112157901.png" alt="image-20210901112157901" style="zoom:80%;"><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestPhantomReference - 演示虚引用的基本用法</li><li>day03.reference.TestWeakReference - 模拟 ThreadLocalMap, 采用引用队列释放 entry 内存</li></ul></blockquote><h2 id="7-finalize"><a href="#7-finalize" class="headerlink" title="7. finalize"></a>7. finalize</h2><p><strong>要求</strong></p><ul><li>掌握 finalize 的工作原理与缺点</li></ul><p><strong>finalize</strong></p><ul><li>它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作</li><li>将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了</li></ul><p><strong>finalize 原理</strong></p><ol><li>对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）</li><li>当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210901121032813.png" alt="image-20210901121032813"></p><ol start="3"><li>Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列</li><li>但此时 Dog 对象还没法被立刻回收，因为 unfinalized -&gt; Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】</li><li>FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法</li></ol><p><img src="/2023-03-05-ffa683208bec/image-20210901122228916.png" alt="image-20210901122228916"></p><ol start="6"><li>由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了</li></ol><p><strong>finalize 缺点</strong></p><ul><li>无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了</li><li>无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）</li><li>内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存</li><li>有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestFinalize - finalize 的测试代码</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚拟机篇&quot;&gt;&lt;a href=&quot;#虚拟机篇&quot; class=&quot;headerlink&quot; title=&quot;虚拟机篇&quot;&gt;&lt;/a&gt;虚拟机篇&lt;/h1&gt;&lt;h2 id=&quot;1-JVM-内存结构&quot;&gt;&lt;a href=&quot;#1-JVM-内存结构&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="面试题" scheme="https://zhuxuchen.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://zhuxuchen.github.io/tags/Java/"/>
    
    <category term="面试题" scheme="https://zhuxuchen.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题全集</title>
    <link href="https://zhuxuchen.github.io/2023-02-26-5496f818735c/"/>
    <id>https://zhuxuchen.github.io/2023-02-26-5496f818735c/</id>
    <published>2023-02-26T08:38:13.000Z</published>
    <updated>2023-02-26T09:31:32.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK、JRE、JVM之间的区别"><a href="#JDK、JRE、JVM之间的区别" class="headerlink" title="JDK、JRE、JVM之间的区别"></a><strong>JDK、JRE、JVM之间的区别</strong></h2><ul><li>JDK(Java SE Development Kit)，Java标准开发包，它提供了<strong>编译</strong>、<strong>运行</strong>Java程序所需的各种工具和资源，包括<strong>Java编译器</strong>、<strong>Java运行时环境</strong>，以及常用的<strong>Java类库</strong>等</li><li>JRE( Java Runtime Environment) ，Java运行环境，用于<strong>运行</strong>Java的字节码文件。JRE中包括了JVM以及JVM工作所需要的类库，普通用户而只需要安装JRE来运行Java程序，而程序开发者必须安装JDK来编译、调试程序。</li><li>JVM(Java Virtual Mechinal)，Java虚拟机，是JRE的一部分，它是整个java实现跨平台的最核心的部分，负责运行字节码文件。</li></ul><p>我们写Java代码，用txt就可以写，但是写出来的Java代码，想要运行，需要先编译成字节码，那就需要编译器，而JDK中就包含了编译器javac，编译之后的字节码，想要运行，就需要一个可以执行字节码的程序，这个程序就是JVM（Java虚拟机），专门用来执行Java字节码的。</p><p>如果我们要开发Java程序，那就需要JDK，因为要编译Java源文件。<br>如果我们只想运行已经编译好的Java字节码文件，也就是*.class文件，那么就只需要JRE。<br>JDK中包含了JRE，JRE中包含了JVM。<br>另外，JVM在执行Java字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令是有可能不一样的，所以就导致不同操作系统上的JVM是不一样的，所以我们在安装JDK时需要选择操作系统。<br>另外，JVM是用来执行Java字节码的，所以凡是某个代码编译之后是Java字节码，那就都能在JVM上运行，比如Apache Groovy, Scala and Kotlin等等。</p><h2 id="hashCode-与equals-之间的关系"><a href="#hashCode-与equals-之间的关系" class="headerlink" title="hashCode()与equals()之间的关系"></a><strong>hashCode()与equals()之间的关系</strong></h2><p>在Java中，每个对象都可以调用自己的hashCode()方法得到自己的哈希值(hashCode)，相当于对象的指纹信息，通常来说世界上没有完全相同的两个指纹，但是在Java中做不到这么绝对，但是我们仍然可以利用hashCode来做一些提前的判断，比如：</p><ul><li>如果两个对象的hashCode不相同，那么这两个对象肯定不同的两个对象</li><li>如果两个对象的hashCode相同，不代表这两个对象一定是同一个对象，也可能是两个对象</li><li>如果两个对象相等，那么他们的hashCode就一定相同</li></ul><p>在Java的一些集合类的实现中，在比较两个对象是否相等时，会根据上面的原则，会先调用对象的hashCode()方法得到hashCode进行比较，如果hashCode不相同，就可以直接认为这两个对象不相同，如果hashCode相同，那么就会进一步调用equals()方法进行比较。而equals()方法，就是用来最终确定两个对象是不是相等的，通常equals方法的实现会比较重，逻辑比较多，而hashCode()主要就是得到一个哈希值，实际上就一个数字，相对而言比较轻，所以在比较两个对象时，通常都会先根据hashCode想比较一下。</p><p>所以我们就需要注意，如果我们重写了equals()方法，那么就要注意hashCode()方法，一定要保证能遵守上述规则。</p><h2 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a><strong>String、StringBuffer、StringBuilder的区别</strong></h2><ol><li>String是不可变的，如果尝试去修改，会新生成一个字符串对象，StringBuffer和StringBuilder是可变的</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率会更高</li></ol><h2 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="泛型中extends和super的区别"></a><strong>泛型中extends和super的区别</strong></h2><ol><li><code>&lt;? extends T&gt;</code>表示包括T在内的任何T的子类</li><li><code>&lt;? super T&gt;</code>表示包括T在内的任何T的父类</li></ol><h2 id="x3D-x3D-和equals方法的区别"><a href="#x3D-x3D-和equals方法的区别" class="headerlink" title="&#x3D;&#x3D;和equals方法的区别"></a><strong>&#x3D;&#x3D;和equals方法的区别</strong></h2><ul><li>&#x3D;&#x3D;：如果是基本数据类型，比较是值，如果是引用类型，比较的是引用地址</li><li>equals：具体看各个类重写equals方法之后的比较逻辑，比如String类，虽然是引用类型，但是String类中重写了equals方法，方法内部比较的是字符串中的各个字符是否全部相等。</li></ul><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a><strong>重载和重写的区别</strong></h2><ul><li>重载(Overload)： 在一个类中，同名的方法如果有不同的参数列表（比如参数类型不同、参数个数不同）则视为重载。</li><li>重写(Override)： 从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型都相同(子类中方法的返回值可以是父类中方法返回值的子类)的情况下， 对方法体进行修改，这就是重写。但要注意子类方法的访问修饰权限不能小于父类的。</li></ul><h2 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a><strong>List和Set的区别</strong></h2><ul><li>List：有序，按对象插入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素</li><li>Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元素，在逐一遍历各个元素</li></ul><h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a><strong>ArrayList和LinkedList区别</strong></h2><ol><li>首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的</li><li>由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同</li><li>另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当做队列来使用</li></ol><h2 id="谈谈ConcurrentHashMap的扩容机制"><a href="#谈谈ConcurrentHashMap的扩容机制" class="headerlink" title="谈谈ConcurrentHashMap的扩容机制"></a><strong>谈谈ConcurrentHashMap的扩容机制</strong></h2><p>1.7版本</p><ol><li>1.7版本的ConcurrentHashMap是基于Segment分段实现的</li><li>每个Segment相对于一个小型的HashMap</li><li>每个Segment内部会进行扩容，和HashMap的扩容逻辑类似</li><li>先生成新的数组，然后转移元素到新数组中</li><li>扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值</li></ol><p>1.8版本</p><ol><li>1.8版本的ConcurrentHashMap不再基于Segment实现</li><li>当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容那么该线程一起进行扩容</li><li>如果某个线程put时，发现没有正在进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进行扩容</li><li>ConcurrentHashMap是支持多个线程同时扩容的</li><li>扩容之前也先生成一个新的数组</li><li>在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作</li></ol><h2 id="Jdk1-7到Jdk1-8-HashMap-发生了什么变化-底层"><a href="#Jdk1-7到Jdk1-8-HashMap-发生了什么变化-底层" class="headerlink" title="Jdk1.7到Jdk1.8 HashMap 发生了什么变化(底层)?"></a><strong>Jdk1.7到Jdk1.8 HashMap 发生了什么变化(底层)?</strong></h2><ol><li>1.7中底层是数组+链表，1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率</li><li>1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8中插入key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使用尾插法</li><li>1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源</li></ol><h2 id="说一下HashMap的Put方法"><a href="#说一下HashMap的Put方法" class="headerlink" title="说一下HashMap的Put方法"></a><strong>说一下HashMap的Put方法</strong></h2><p>先说HashMap的Put方法的大体流程：</p><ol><li>根据Key通过哈希算法与与运算得出数组下标</li><li>如果数组下标位置元素为空，则将key和value封装为Entry对象（JDK1.7中是Entry对象，JDK1.8中是Node对象）并放入该位置</li><li>如果数组下标位置元素不为空，则要分情况讨论<ol><li>如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中</li><li>如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红黑树Node，还是链表Node<ol><li>如果是红黑树Node，则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value</li><li>如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插入到链表中，插入到链表后，会看当前链表的节点个数，如果大于等于8，那么则会将该链表转成红黑树</li><li>将key和value封装为Node插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就结束PUT方法</li></ol></li></ol></li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a><strong>深拷贝和浅拷贝</strong></h2><p>深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。</p><ol><li>浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象</li><li>深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象</li></ol><h2 id="HashMap的扩容机制原理"><a href="#HashMap的扩容机制原理" class="headerlink" title="HashMap的扩容机制原理"></a><strong>HashMap的扩容机制原理</strong></h2><p>1.7版本</p><ol><li>先生成新数组</li><li>遍历老数组中的每个位置上的链表上的每个元素</li><li>取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标</li><li>将元素添加到新数组中去</li><li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li></ol><p>1.8版本</p><ol><li>先生成新数组</li><li>遍历老数组中的每个位置上的链表或红黑树</li><li>如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去</li><li>如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置<ol><li>统计每个下标位置的元素个数</li><li>如果该位置下的元素个数超过了6，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置</li><li>如果该位置下的元素个数没有超过6，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置</li></ol></li><li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li></ol><h2 id="CopyOnWriteArrayList的底层原理是怎样的"><a href="#CopyOnWriteArrayList的底层原理是怎样的" class="headerlink" title="CopyOnWriteArrayList的底层原理是怎样的"></a><strong>CopyOnWriteArrayList的底层原理是怎样的</strong></h2><ol><li>首先CopyOnWriteArrayList内部也是用过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新数组上进行，读操作在原数组上进行</li><li>并且，写操作会加锁，防止出现并发写入丢失数据的问题</li><li>写操作结束之后会把原数组指向新数组</li><li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场景，但是CopyOnWriteArrayList会比较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li></ol><h2 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a><strong>什么是字节码？采用字节码的好处是什么？</strong></h2><p>编译器(javac)将Java源文件(<em>.java)文件编译成为字节码文件(</em>.class)，可以做到一次编译到处运行，windows上编译好的class文件，可以直接在linux上运行，通过这种方式做到跨平台，不过Java的跨平台有一个前提条件，就是不同的操作系统上安装的JDK或JRE是不一样的，虽然字节码是通用的，但是需要把字节码解释成各个操作系统的机器码是需要不同的解释器的，所以针对各个操作系统需要有各自的JDK或JRE。</p><p>采用字节码的好处，一方面实现了跨平台，另外一方面也提高了代码执行的性能，编译器在编译源代码时可以做一些编译期的优化，比如锁消除、标量替换、方法内联等。</p><h2 id="Java中的异常体系是怎样的"><a href="#Java中的异常体系是怎样的" class="headerlink" title="Java中的异常体系是怎样的"></a><strong>Java中的异常体系是怎样的</strong></h2><ul><li>Java中的所有异常都来自顶级父类Throwable。</li><li>Throwable下有两个子类Exception和Error。</li><li>Error表示非常严重的错误，比如java.lang.StackOverFlowError和Java.lang.OutOfMemoryError，通常这些错误出现时，仅仅想靠程序自己是解决不了的，可能是虚拟机、磁盘、操作系统层面出现的问题了，所以通常也不建议在代码中去捕获这些Error，因为捕获的意义不大，因为程序可能已经根本运行不了了。</li><li>Exception表示异常，表示程序出现Exception时，是可以靠程序自己来解决的，比如NullPointerException、IllegalAccessException等，我们可以捕获这些异常来做特殊处理。</li><li>Exception的子类通常又可以分为RuntimeException和非RuntimeException两类</li><li>RunTimeException表示运行期异常，表示这个异常是在代码运行过程中抛出的，这些异常是非检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生，比如NullPointerException、IndexOutOfBoundsException等。</li><li>非RuntimeException表示非运行期异常，也就是我们常说的检查异常，是必须进行处理的异常，如果不处理，程序就不能检查异常通过。如IOException、SQLException等以及用户自定义的Exception异常。</li></ul><h2 id="在Java的异常处理机制中，什么时候应该抛出异常，什么时候捕获异常？"><a href="#在Java的异常处理机制中，什么时候应该抛出异常，什么时候捕获异常？" class="headerlink" title="在Java的异常处理机制中，什么时候应该抛出异常，什么时候捕获异常？"></a><strong>在Java的异常处理机制中，什么时候应该抛出异常，什么时候捕获异常？</strong></h2><p>异常相当于一种提示，如果我们抛出异常，就相当于告诉上层方法，我抛了一个异常，我处理不了这个异常，交给你来处理，而对于上层方法来说，它也需要决定自己能不能处理这个异常，是否也需要交给它的上层。</p><p>所以我们在写一个方法时，我们需要考虑的就是，本方法能否合理的处理该异常，如果处理不了就继续向上抛出异常，包括本方法中在调用另外一个方法时，发现出现了异常，如果这个异常应该由自己来处理，那就捕获该异常并进行处理。</p><h2 id="Java中有哪些类加载器"><a href="#Java中有哪些类加载器" class="headerlink" title="Java中有哪些类加载器"></a><strong>Java中有哪些类加载器</strong></h2><p>JDK自带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。</p><ul><li>BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和class文件。</li><li>ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%&#x2F;lib&#x2F;ext文件夹下的jar包和class类。</li><li>AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。</li></ul><h2 id="说说类加载器双亲委派模型"><a href="#说说类加载器双亲委派模型" class="headerlink" title="说说类加载器双亲委派模型"></a><strong>说说类加载器双亲委派模型</strong></h2><p>JVM中存在三个默认的类加载器：</p><ol><li>BootstrapClassLoader</li><li>ExtClassLoader</li><li>AppClassLoader</li></ol><p>AppClassLoader的父加载器是ExtClassLoader，ExtClassLoader的父加载器是BootstrapClassLoader。</p><p>JVM在加载一个类时，会调用AppClassLoader的loadClass方法来加载这个类，不过在这个方法中，会先使用ExtClassLoader的loadClass方法来加载类，同样ExtClassLoader的loadClass方法中会先使用BootstrapClassLoader来加载类，如果BootstrapClassLoader加载到了就直接成功，如果BootstrapClassLoader没有加载到，那么ExtClassLoader就会自己尝试加载该类，如果没有加载到，那么则会由AppClassLoader来加载这个类。</p><p>所以，双亲委派指得是，JVM在加载类时，会委派给Ext和Bootstrap进行加载，如果没加载到才由自己进行加载。</p><h2 id="JVM中哪些是线程共享区"><a href="#JVM中哪些是线程共享区" class="headerlink" title="JVM中哪些是线程共享区"></a><strong>JVM中哪些是线程共享区</strong></h2><p>堆区和方法区是所有线程共享的，栈、本地方法栈、程序计数器是每个线程独有的<br><img src="/2023-02-26-5496f818735c/JVM%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%8C%BA.png"></p><h2 id="你们项目如何排查JVM问题"><a href="#你们项目如何排查JVM问题" class="headerlink" title="你们项目如何排查JVM问题"></a><strong>你们项目如何排查JVM问题</strong></h2><p>对于还在正常运行的系统：</p><ol><li>可以使用jmap来查看JVM中各个区域的使用情况</li><li>可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现了死锁</li><li>可以通过jstat命令来查看垃圾回收的情况，特别是fullgc，如果发现fullgc比较频繁，那么就得进行调优了</li><li>通过各个命令的结果，或者jvisualvm等工具来进行分析</li><li>首先，初步猜测频繁发送fullgc的原因，如果频繁发生fullgc但是又一直没有出现内存溢出，那么表示fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进入到老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入到了老年代，尝试加大年轻代的大小，如果改完之后，fullgc减少，则证明修改有效</li><li>同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存</li></ol><p>对于已经发生了OOM的系统：</p><ol><li>一般生产系统中都会设置当系统发生了OOM时，生成当时的dump文件（-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;usr&#x2F;local&#x2F;base）</li><li>我们可以利用jsisualvm等工具来分析dump文件</li><li>根据dump文件找到异常的实例对象，和异常的线程（占用CPU高），定位到具体的代码</li><li>然后再进行详细的分析和调试</li></ol><p>总之，调优不是一蹴而就的，需要分析、推理、实践、总结、再分析，最终定位到具体的问题</p><h2 id="一个对象从加载到JVM，再到被GC清除，都经历了什么过程？"><a href="#一个对象从加载到JVM，再到被GC清除，都经历了什么过程？" class="headerlink" title="一个对象从加载到JVM，再到被GC清除，都经历了什么过程？"></a><strong>一个对象从加载到JVM，再到被GC清除，都经历了什么过程？</strong></h2><ol><li>首先把字节码文件内容加载到方法区</li><li>然后再根据类信息在堆区创建对象</li><li>对象首先会分配在堆区中年轻代的Eden区，经过一次Minor GC后，对象如果存活，就会进入Suvivor区。在后续的每次Minor GC中，如果对象一直存活，就会在Suvivor区来回拷贝，每移动一次，年龄加1</li><li>当年龄超过15后，对象依然存活，对象就会进入老年代</li><li>如果经过Full GC，被标记为垃圾对象，那么就会被GC线程清理掉</li></ol><h2 id="怎么确定一个对象到底是不是垃圾？"><a href="#怎么确定一个对象到底是不是垃圾？" class="headerlink" title="怎么确定一个对象到底是不是垃圾？"></a><strong>怎么确定一个对象到底是不是垃圾？</strong></h2><ol><li>引用计数算法： 这种方式是给堆内存当中的每个对象记录一个引用个数。引用个数为0的就认为是垃圾。这是早期JDK中使用的方式。引用计数无法解决循环引用的问题。</li><li>可达性算法： 这种方式是在内存中，从根对象向下一直找引用，找到的对象就不是垃圾，没找到的对象就是垃圾。</li></ol><h2 id="JVM有哪些垃圾回收算法？"><a href="#JVM有哪些垃圾回收算法？" class="headerlink" title="JVM有哪些垃圾回收算法？"></a><strong>JVM有哪些垃圾回收算法？</strong></h2><ol><li>标记清除算法：<ol><li>标记阶段：把垃圾内存标记出来</li><li>清除阶段：直接将垃圾内存回收。</li><li>这种算法是比较简单的，但是有个很严重的问题，就是会产生大量的内存碎片。</li></ol></li><li>复制算法：为了解决标记清除算法的内存碎片问题，就产生了复制算法。复制算法将内存分为大小相等的两半，每次只使用其中一半。垃圾回收时，将当前这一块的存活对象全部拷贝到另一半，然后当前这一半内存就可以直接清除。这种算法没有内存碎片，但是他的问题就在于浪费空间。而且，他的效率跟存活对象的个数有关。</li><li>标记压缩算法：为了解决复制算法的缺陷，就提出了标记压缩算法。这种算法在标记阶段跟标记清除算法是一样的，但是在完成标记之后，不是直接清理垃圾内存，而是将存活对象往一端移动，然后将边界以外的所有内存直接清除。</li></ol><h2 id="什么是STW？"><a href="#什么是STW？" class="headerlink" title="什么是STW？"></a><strong>什么是STW？</strong></h2><p>STW: Stop-The-World，是在垃圾回收算法执行过程当中，需要将JVM内存冻结的一种状态。在STW状态下，JAVA的所有线程都是停止执行的-GC线程除外，native方法可以执行，但是，不能与JVM交互。GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。</p><h2 id="JVM参数有哪些？"><a href="#JVM参数有哪些？" class="headerlink" title="JVM参数有哪些？"></a><strong>JVM参数有哪些？</strong></h2><p>JVM参数大致可以分为三类：</p><ol><li>标注指令： -开头，这些是所有的HotSpot都支持的参数。可以用java -help 打印出来。</li><li>非标准指令： -X开头，这些指令通常是跟特定的HotSpot版本对应的。可以用java -X 打印出来。</li><li>不稳定参数： -XX 开头，这一类参数是跟特定HotSpot版本对应的，并且变化非常大。</li></ol><h2 id="说说对线程安全的理解"><a href="#说说对线程安全的理解" class="headerlink" title="说说对线程安全的理解"></a><strong>说说对线程安全的理解</strong></h2><p>线程安全指的是，我们写的某段代码，在多个线程同时执行这段代码时，不会产生混乱，依然能够得到正常的结果，比如i++，i初始化值为0，那么两个线程来同时执行这行代码，如果代码是线程安全的，那么最终的结果应该就是一个线程的结果为1，一个线程的结果为2，如果出现了两个线程的结果都为1，则表示这段代码是线程不安全的。</p><p>所以线程安全，主要指的是一段代码在多个线程同时执行的情况下，能否得到正确的结果。</p><h2 id="对守护线程的理解"><a href="#对守护线程的理解" class="headerlink" title="对守护线程的理解"></a><strong>对守护线程的理解</strong></h2><p>线程分为用户线程和守护线程，用户线程就是普通线程，守护线程就是JVM的后台线程，比如垃圾回收线程就是一个守护线程，守护线程会在其他普通线程都停止运行之后自动关闭。我们可以通过设置thread.setDaemon(true)来把一个线程设置为守护线程。</p><h2 id="ThreadLocal的底层原理"><a href="#ThreadLocal的底层原理" class="headerlink" title="ThreadLocal的底层原理"></a><strong>ThreadLocal的底层原理</strong></h2><ol><li>ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据</li><li>ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值</li><li>如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key，value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清楚Entry对象</li><li>ThreadLocal经典的应用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接）</li></ol><p><img src="/2023-02-26-5496f818735c/image.png"></p><h2 id="并发、并行、串行之间的区别"><a href="#并发、并行、串行之间的区别" class="headerlink" title="并发、并行、串行之间的区别"></a><strong>并发、并行、串行之间的区别</strong></h2><ol><li>串行：一个任务执行完，才能执行下一个任务</li><li>并行(Parallelism)：两个任务同时执行</li><li>并发(Concurrency)：两个任务整体看上去是同时执行，在底层，两个任务被拆成了很多份，然后一个一个执行，站在更高的角度看来两个任务是同时在执行的</li></ol><h2 id="Java死锁如何避免？"><a href="#Java死锁如何避免？" class="headerlink" title="Java死锁如何避免？"></a><strong>Java死锁如何避免？</strong></h2><p>造成死锁的几个原因：</p><ol><li>一个资源每次只能被一个线程使用</li><li>一个线程在阻塞等待某个资源时，不释放已占有资源</li><li>一个线程已经获得的资源，在未使用完之前，不能被强行剥夺</li><li>若干线程形成头尾相接的循环等待资源关系</li></ol><p>这是造成死锁必须要达到的4个条件，如果要避免死锁，只需要不满足其中某一个条件即可。而其中前3个条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待锁的关系。</p><p>在开发过程中：</p><ol><li>要注意加锁顺序，保证每个线程按同样的顺序进行加锁</li><li>要注意加锁时限，可以针对所设置一个超时时间</li><li>要注意死锁检查，这是一种预防机制，确保在第一时间发现死锁并进行解决</li></ol><h2 id="线程池的底层工作原理"><a href="#线程池的底层工作原理" class="headerlink" title="线程池的底层工作原理"></a><strong>线程池的底层工作原理</strong></h2><p>线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时：</p><ol><li>如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li><li>如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。</li><li>如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li><li>如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。</li><li>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数</li></ol><h2 id="线程池为什么是先添加列队而不是先创建最大线程？"><a href="#线程池为什么是先添加列队而不是先创建最大线程？" class="headerlink" title="线程池为什么是先添加列队而不是先创建最大线程？"></a><strong>线程池为什么是先添加列队而不是先创建最大线程？</strong></h2><p>当线程池中的核心线程都在忙时，如果继续往线程池中添加任务，那么任务会先放入队列，队列满了之后，才会新开线程。这就相当于，一个公司本来有10个程序员，本来这10个程序员能正常的处理各种需求，但是随着公司的发展，需求在慢慢的增加，但是一开始这些需求只会增加在待开发列表中，然后这10个程序员加班加点的从待开发列表中获取需求并进行处理，但是某一天待开发列表满了，公司发现现有的10个程序员是真的处理不过来了，所以就开始新招员工了。</p><h2 id="ReentrantLock中的公平锁和非公平锁的底层实现"><a href="#ReentrantLock中的公平锁和非公平锁的底层实现" class="headerlink" title="ReentrantLock中的公平锁和非公平锁的底层实现"></a><strong>ReentrantLock中的公平锁和非公平锁的底层实现</strong></h2><p>首先不管是公平锁和非公平锁，它们的底层实现都会使用AQS来进行排队，它们的区别在于：线程在使用lock()方法加锁时，如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队，则当前线程也进行排队，如果是非公平锁，则不会去检查是否有线程在排队，而是直接竞争锁。</p><p>不管是公平锁还是非公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁只是体现在了线程加锁阶段，而没有体现在线程被唤醒阶段。</p><p>另外，ReentrantLock是可重入锁，不管是公平锁还是非公平锁都是可重入的。<br><img src="/2023-02-26-5496f818735c/ReentrantLock%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81.png"><img src="/2023-02-26-5496f818735c/ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81.png"></p><h2 id="ReentrantLock中tryLock-和lock-方法的区别"><a href="#ReentrantLock中tryLock-和lock-方法的区别" class="headerlink" title="ReentrantLock中tryLock()和lock()方法的区别"></a><strong>ReentrantLock中tryLock()和lock()方法的区别</strong></h2><ol><li>tryLock()表示尝试加锁，可能加到，也可能加不到，该方法不会阻塞线程，如果加到锁则返回true，没有加到则返回false</li><li>lock()表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值</li></ol><h2 id="CountDownLatch和Semaphore的区别和底层原理"><a href="#CountDownLatch和Semaphore的区别和底层原理" class="headerlink" title="CountDownLatch和Semaphore的区别和底层原理"></a><strong>CountDownLatch和Semaphore的区别和底层原理</strong></h2><p>CountDownLatch表示计数器，可以给CountDownLatch设置一个数字，一个线程调用CountDownLatch的await()将会阻塞，其他线程可以调用CountDownLatch的countDown()方法来对CountDownLatch中的数字减一，当数字被减成0后，所有await的线程都将被唤醒。<br>对应的底层原理就是，调用await()方法的线程会利用AQS排队，一旦数字被减为0，则会将AQS中排队的线程依次唤醒。</p><p>Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过acquire()来获取许可，如果没有许可可用则线程阻塞，并通过AQS来排队，可以通过release()方法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第一个线程开始依次唤醒，直到没有空闲许可。</p><h2 id="Sychronized的偏向锁、轻量级锁、重量级锁"><a href="#Sychronized的偏向锁、轻量级锁、重量级锁" class="headerlink" title="Sychronized的偏向锁、轻量级锁、重量级锁"></a><strong>Sychronized的偏向锁、轻量级锁、重量级锁</strong></h2><ol><li>偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来获取该锁就可以直接获取到了</li><li>轻量级锁：由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果有第二个线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻量级锁底层是通过自旋来实现的，并不会阻塞线程</li><li>如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞</li><li>自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。</li></ol><h2 id="Sychronized和ReentrantLock的区别"><a href="#Sychronized和ReentrantLock的区别" class="headerlink" title="Sychronized和ReentrantLock的区别"></a><strong>Sychronized和ReentrantLock的区别</strong></h2><ol><li>sychronized是一个关键字，ReentrantLock是一个类</li><li>sychronized会自动的加锁与释放锁，ReentrantLock需要程序员手动加锁与释放锁</li><li>sychronized的底层是JVM层面的锁，ReentrantLock是API层面的锁</li><li>sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁</li><li>sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识来标识锁的状态</li><li>sychronized底层有一个锁升级的过程</li></ol><h2 id="谈谈你对AQS的理解，AQS如何实现可重入锁？"><a href="#谈谈你对AQS的理解，AQS如何实现可重入锁？" class="headerlink" title="谈谈你对AQS的理解，AQS如何实现可重入锁？"></a><strong>谈谈你对AQS的理解，AQS如何实现可重入锁？</strong></h2><ol><li>AQS是一个JAVA线程同步的框架。是JDK中很多锁工具的核心实现框架。</li><li>在AQS中，维护了一个信号量state和一个线程组成的双向链表队列。其中，这个线程队列，就是用来给线程排队的，而state就像是一个红绿灯，用来控制线程排队或者放行的。 在不同的场景下，有不用的意义。</li><li>在可重入锁这个场景下，state就用来表示加锁的次数。0标识无锁，每加一次锁，state就加1。释放锁state就减1。</li></ol><h2 id="谈谈你对IOC的理解"><a href="#谈谈你对IOC的理解" class="headerlink" title="谈谈你对IOC的理解"></a><strong>谈谈你对IOC的理解</strong></h2><p>通常，我们认为Spring有两大特性IoC和AOP，那到底该如何理解IoC呢？<br>对于很多初学者来说，IoC这个概念给人的感觉就是<strong>我好像会，但是我说不出来</strong>。</p><p>那么IoC到底是什么，接下来来说说我的理解，实际上这是一个非常大的问题，所以我们就把它拆细了来回答，IoC表示控制反转，那么：</p><ol><li>什么是控制？控制了什么？</li><li>什么是反转？反转之前是谁控制的？反转之后是谁控制的？如何控制的？</li><li>为什么要反转？反转之前有什么问题？反转之后有什么好处？</li></ol><p>这就是解决这一类大问题的思路，大而化小。</p><p>那么，我们先来解决第一个问题：<strong>什么是控制？控制了什么？</strong><br>我们在用Spring的时候，我们需要做什么：</p><ol><li>建一些类，比如UserService、OrderService</li><li>用一些注解，比如@Autowired</li></ol><p>但是，我们也知道，当程序运行时，用的是具体的UserService对象、OrderService对象，那这些对象是什么时候创建的？谁创建的？包括对象里的属性是什么时候赋的值？谁赋的？所有这些都是我们程序员做的，以为我们只是写了类而已，所有的这些都是Spring做的，它才是幕后黑手。</p><p>这就是<strong>控制</strong>：</p><ol><li>控制对象的创建</li><li>控制对象内属性的赋值</li></ol><p>如果我们不用Spring，那我们得自己来做这两件事，反过来，我们用Spring，这两件事情就不用我们做了，我们要做的仅仅是定义类，以及定义哪些属性需要Spring来赋值（比如某个属性上加@Autowired），而这其实就是第二个问题的答案，这就是<strong>反转</strong>，表示一种<strong>对象控制权</strong>的转移。</p><p>那反转有什么用，为什么要反转？<br>如果我们自己来负责创建对象，自己来给对象中的属性赋值，会出现什么情况？</p><p>比如，现在有三个类：</p><ol><li>A类，A类里有一个属性C c；</li><li>B类，B类里也有一个属性C c；</li><li>C类</li></ol><p>现在程序要运行，这三个类的对象都需要创建出来，并且相应的属性都需要有值，那么除开定义这三个类之外，我们还得写：</p><ol><li><code>A a = new A();</code></li><li><code>B b = new B();</code></li><li><code>C c = new C();</code></li><li><code>a.c = c;</code></li><li><code>b.c = c;</code></li></ol><p>这五行代码是不用Spring的情况下多出来的代码，而且，如果类在多一些，类中的属性在多一些，那相应的代码会更多，而且代码会更复杂。所以我们可以发现，我们自己来控制比交给Spring来控制，我们的代码量以及代码复杂度是要高很多的，反言之，将对象交给Spring来控制，减轻了程序员的负担。</p><p>总结一下，IoC表示控制反转，表示如果用Spring，那么Spring会负责来创建对象，以及给对象内的属性赋值，也就是如果用Spring，那么对象的控制权会转交给Spring。</p><h2 id="单例Bean和单例模式"><a href="#单例Bean和单例模式" class="headerlink" title="单例Bean和单例模式"></a><strong>单例Bean和单例模式</strong></h2><p>单例模式表示JVM中某个类的对象只会存在唯一一个。<br>而单例Bean并不表示JVM中只能存在唯一的某个类的Bean对象。</p><h2 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a><strong>Spring事务传播机制</strong></h2><p>多个事务方法相互调用时，事务如何在这些方法间传播，方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。</p><ol><li>1REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</li><li>SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</li><li>MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</li><li>REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。</li><li>NOT_SUPPORTED：以非事务方式执行,如果当前存在事务，则挂起当前事务</li><li>NEVER：不使用事务，如果当前事务存在，则抛出异常</li><li>NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）</li></ol><h2 id="Spring事务什么时候会失效"><a href="#Spring事务什么时候会失效" class="headerlink" title="Spring事务什么时候会失效?"></a><strong>Spring事务什么时候会失效?</strong></h2><p>spring事务的原理是AOP，进行了切面增强，那么失效的根本原因是这个AOP不起作用了！常见情况有如下几种</p><ol><li>发生自调用，类里面使用this调用本类的方法（this通常省略），此时这个this对象不是代理类，而是UserService对象本身！ 解决方法很简单，让那个this变成UserService的代理类即可！</li><li>方法不是public的：@Transactional 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式。</li><li>数据库不支持事务</li><li>没有被spring管理</li><li>异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为RuntimeException)</li></ol><h2 id="Spring中的Bean创建的生命周期有哪些步骤"><a href="#Spring中的Bean创建的生命周期有哪些步骤" class="headerlink" title="Spring中的Bean创建的生命周期有哪些步骤"></a><strong>Spring中的Bean创建的生命周期有哪些步骤</strong></h2><p>Spring中一个Bean的创建大概分为以下几个步骤：</p><ol><li>推断构造方法</li><li>实例化</li><li>填充属性，也就是依赖注入</li><li>处理Aware回调</li><li>初始化前，处理@PostConstruct注解</li><li>初始化，处理InitializingBean接口</li><li>初始化后，进行AOP</li></ol><p>当然其实真正的步骤更加细致，可以看下面的流程图<br><img src="/2023-02-26-5496f818735c/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><h2 id="Spring中Bean是线程安全的吗"><a href="#Spring中Bean是线程安全的吗" class="headerlink" title="Spring中Bean是线程安全的吗"></a><strong>Spring中Bean是线程安全的吗</strong></h2><p>Spring本身并没有针对Bean做线程安全的处理，所以：</p><ol><li>如果Bean是无状态的，那么Bean则是线程安全的</li><li>如果Bean是有状态的，那么Bean则不是线程安全的</li></ol><p>另外，Bean是不是线程安全，跟Bean的作用域没有关系，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期的Bean都是一个对象，这个对象是不是线程安全的，还是得看这个Bean对象本身。</p><h2 id="ApplicationContext和BeanFactory有什么区别"><a href="#ApplicationContext和BeanFactory有什么区别" class="headerlink" title="ApplicationContext和BeanFactory有什么区别"></a><strong>ApplicationContext和BeanFactory有什么区别</strong></h2><p>BeanFactory是Spring中非常核心的组件，表示Bean工厂，可以生成Bean，维护Bean，而ApplicationContext继承了BeanFactory，所以ApplicationContext拥有BeanFactory所有的特点，也是一个Bean工厂，但是ApplicationContext除开继承了BeanFactory之外，还继承了诸如EnvironmentCapable、MessageSource、ApplicationEventPublisher等接口，从而ApplicationContext还有获取系统环境变量、国际化、事件发布等功能，这是BeanFactory所不具备的</p><h2 id="Spring中的事务是如何实现的"><a href="#Spring中的事务是如何实现的" class="headerlink" title="Spring中的事务是如何实现的"></a><strong>Spring中的事务是如何实现的</strong></h2><ol><li>Spring事务底层是基于数据库事务和AOP机制的</li><li>首先对于使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean</li><li>当调用代理对象的方法时，会先判断该方法上是否加了@Transactional注解</li><li>如果加了，那么则利用事务管理器创建一个数据库连接</li><li>并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步</li><li>然后执行当前方法，方法中会执行sql</li><li>执行完当前方法后，如果没有出现异常就直接提交事务</li><li>如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务</li><li>Spring事务的隔离级别对应的就是数据库的隔离级别</li><li>Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的</li><li>Spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据库连接上执行sql</li></ol><p>![](面试题全集&#x2F;Spring事务的底层实现流程 (1).png)</p><h2 id="Spring中什么时候-Transactional-会失效"><a href="#Spring中什么时候-Transactional-会失效" class="headerlink" title="Spring中什么时候**@Transactional**会失效"></a><strong>Spring中什么时候</strong><code>**@Transactional**</code><strong>会失效</strong></h2><p>因为Spring事务是基于代理来实现的，所以某个加了<code>@Transactional</code>的方法只有是被代理对象调用时，那么这个注解才会生效，所以如果是被代理对象来调用这个方法，那么<code>@Transactional</code>是不会失效的。</p><p>同时如果某个方法是private的，那么<code>@Transactional</code>也会失效，因为底层cglib是基于父子类来实现的，子类是不能重载父类的private方法的，所以无法很好的利用代理，也会导致<code>@Transactianal</code>失效</p><h2 id="Spring容器启动流程是怎样的"><a href="#Spring容器启动流程是怎样的" class="headerlink" title="Spring容器启动流程是怎样的"></a><strong>Spring容器启动流程是怎样的</strong></h2><ol><li>在创建Spring容器，也就是启动Spring时：</li><li>首先会进行扫描，扫描得到所有的BeanDefinition对象，并存在一个Map中</li><li>然后筛选出非懒加载的单例BeanDefinition进行创建Bean，对于多例Bean不需要在启动过程中去进行创建，对于多例Bean会在每次获取Bean时利用BeanDefinition去创建</li><li>利用BeanDefinition创建Bean就是Bean的创建生命周期，这期间包括了合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发生在初始化后这一步骤中</li><li>单例Bean创建完了之后，Spring会发布一个容器启动事件</li><li>Spring启动结束</li><li>在源码中会更复杂，比如源码中会提供一些模板方法，让子类来实现，比如源码中还涉及到一些BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过BenaFactoryPostProcessor来实现的，依赖注入就是通过BeanPostProcessor来实现的</li><li>在Spring启动过程中还会去处理<code>@Import</code>等注解</li></ol><p><img src="/2023-02-26-5496f818735c/Spring%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3.png"></p><h2 id="Spring用到了哪些设计模式"><a href="#Spring用到了哪些设计模式" class="headerlink" title="Spring用到了哪些设计模式"></a><strong>Spring用到了哪些设计模式</strong></h2><p><img src="/2023-02-26-5496f818735c/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png"></p><h2 id="Spring-Boot中常用注解及其底层实现"><a href="#Spring-Boot中常用注解及其底层实现" class="headerlink" title="Spring Boot中常用注解及其底层实现"></a><strong>Spring Boot中常用注解及其底层实现</strong></h2><ol><li><code>@SpringBootApplication</code>注解：这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，这三个注解是：<ol><li><code>@SpringBootConfiguration</code>：这个注解实际就是一个<code>@Configuration</code>，表示启动类也是一个配置类</li><li><code>@EnableAutoConfiguration</code>：向Spring容器中导入了一个Selector，用来加载ClassPath下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean</li><li><code>@ComponentScan</code>：标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前目录</li></ol></li><li><code>@Bean</code>注解：用来定义Bean，类似于XML中的<code>&lt;bean&gt;</code>标签，Spring在启动时，会对加了<code>@Bean</code>注解的方法进行解析，将方法的名字做为beanName，并通过执行方法得到bean对象</li><li><code>@Controller</code>、<code>@Service</code>、<code>@ResponseBody</code>、<code>@Autowired</code>都可以说</li></ol><h2 id="Spring-Boot是如何启动Tomcat的"><a href="#Spring-Boot是如何启动Tomcat的" class="headerlink" title="Spring Boot是如何启动Tomcat的"></a><strong>Spring Boot是如何启动Tomcat的</strong></h2><ol><li>首先，SpringBoot在启动时会先创建一个Spring容器</li><li>在创建Spring容器过程中，会利用<code>@ConditionalOnClass</code>技术来判断当前classpath中是否存在Tomcat依赖，如果存在则会生成一个启动Tomcat的Bean</li><li>Spring容器创建完之后，就会获取启动Tomcat的Bean，并创建Tomcat对象，并绑定端口等，然后启动Tomcat</li></ol><h2 id="Mybatis的优缺点"><a href="#Mybatis的优缺点" class="headerlink" title="Mybatis的优缺点"></a><strong>Mybatis的优缺点</strong></h2><p>优点：</p><ol><li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签， 支持编写动态 SQL 语句， 并可重用。</li><li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</li><li>很好的与各种数据库兼容（ 因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库 MyBatis 都支持）。</li><li>能够与 Spring 很好的集成；</li><li>提供映射标签， 支持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， 支持对象关系组件维护。</li></ol><p>缺点：</p><ol><li>SQL 语句的编写工作量较大， 尤其当字段多、关联表多时， 对开发人员编写SQL 语句的功底有一定要求。</li><li>SQL 语句依赖于数据库， 导致数据库移植性差， 不能随意更换数据库。</li></ol><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="**#{}**和**${}**的区别是什么？"></a><code>**#&#123;&#125;**</code><strong>和</strong><code>**$&#123;&#125;**</code><strong>的区别是什么？</strong></h2><ul><li><code>#&#123;&#125;</code>是预编译处理、是占位符，<code> $&#123;&#125;</code>是字符串替换、是拼接符。</li><li>Mybatis在处理<code>#&#123;&#125;</code>时，会将sql中的<code>#&#123;&#125;</code>替换为?号，调用 PreparedStatement 来赋值</li><li>Mybatis在处理<code>$&#123;&#125;</code>时，会将sql中的<code>$&#123;&#125;</code>替换成变量的值，调用 Statement 来赋值</li><li>使用<code>#&#123;&#125;</code>可以有效的防止 SQL 注入， 提高系统安全性</li></ul><h2 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a><strong>索引的基本原理</strong></h2><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>索引的原理：就是把无序的数据变成有序的查询</p><ol><li>把创建了索引的列的内容进行排序</li><li>对排序结果生成倒排表</li><li>在倒排表内容上拼上数据地址链</li><li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li></ol><h2 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a><strong>索引设计的原则？</strong></h2><p>查询更快、占用空间更小</p><ol><li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li><li>基数较小的表，索引效果较差，没有必要在此列建立索引</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。</li><li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li><li>定义有外键的数据列一定要建立索引。</li><li>更新频繁字段不适合创建索引</li><li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li><li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li><li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li><li>对于定义为text、image和bit的数据类型的列不要建立索引。</li></ol><h2 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a><strong>事务的基本特性和隔离级别</strong></h2><p>事务基本特性ACID分别是：</p><p><strong>原子性</strong>指的是一个事务中的操作要么全部成功，要么全部失败。</p><p><strong>一致性</strong>指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设A只有90块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证</p><p><strong>隔离性</strong>指的是一个事务的修改在最终提交前，对其他事务是不可见的。</p><p><strong>持久性</strong>指的是一旦事务提交，所做的修改就会永久保存到数据库中。</p><p>隔离性有4个隔离级别，分别是：</p><ul><li>read uncommit  读未提交，可能会读到其他事务未提交的数据，也叫做脏读。 用户本来应该读取到id&#x3D;1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age&#x3D;20，这就是脏读。 </li><li>read commit  读已提交，两次读取结果不一致，叫做不可重复读。 不可重复读解决了脏读的问题，他只会读取已经提交的事务。 用户开启事务读取id&#x3D;1用户，查询到age&#x3D;10，再次读取发现结果&#x3D;20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。 </li><li>repeatable read  可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。 </li><li>serializable  串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。</li></ul><h2 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a><strong>什么是MVCC</strong></h2><p>MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程。可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p><h2 id="简述MyISAM和InnoDB的区别"><a href="#简述MyISAM和InnoDB的区别" class="headerlink" title="简述MyISAM和InnoDB的区别"></a><strong>简述MyISAM和InnoDB的区别</strong></h2><p><strong>MyISAM：</strong></p><ul><li>不支持事务，但是每次查询都是原子的；</li><li>支持表级锁，即每次操作是对整个表加锁；</li><li>存储表的总行数；</li><li>一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；</li><li>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</li></ul><p><strong>InnoDb：</strong></p><ul><li>支持ACID的事务，支持事务的四种隔离级别；</li><li>支持行级锁及外键约束：因此可以支持写并发；</li><li>不存储总行数；</li><li>一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；</li><li>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</li></ul><h2 id="Explain语句结果中各个字段分表表示什么"><a href="#Explain语句结果中各个字段分表表示什么" class="headerlink" title="Explain语句结果中各个字段分表表示什么"></a><strong>Explain语句结果中各个字段分表表示什么</strong></h2><table><thead><tr><th align="center">列名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值，某些子查询会被优化为join查询，那么出现的id会一样</td></tr><tr><td align="center">select_type</td><td align="center">SELECT关键字对应的那个查询的类型</td></tr><tr><td align="center">table</td><td align="center">表名</td></tr><tr><td align="center">partitions</td><td align="center">匹配的分区信息</td></tr><tr><td align="center">type</td><td align="center">针对单表的查询方式（全表扫描、索引）</td></tr><tr><td align="center">possible_keys</td><td align="center">可能用到的索引</td></tr><tr><td align="center">key</td><td align="center">实际上使用的索引</td></tr><tr><td align="center">key_len</td><td align="center">实际使用到的索引长度</td></tr><tr><td align="center">ref</td><td align="center">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td align="center">rows</td><td align="center">预估的需要读取的记录条数</td></tr><tr><td align="center">filtered</td><td align="center">某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td align="center">Extra</td><td align="center">一些额外的信息，比如排序等</td></tr></tbody></table><h2 id="索引覆盖是什么"><a href="#索引覆盖是什么" class="headerlink" title="索引覆盖是什么"></a><strong>索引覆盖是什么</strong></h2><p>索引覆盖就是一个SQL在执行时，可以利用索引来快速查找，并且此SQL所要查询的字段在当前索引对应的字段中都包含了，那么就表示此SQL走完索引后不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回了</p><h2 id="最左前缀原则是什么"><a href="#最左前缀原则是什么" class="headerlink" title="最左前缀原则是什么"></a><strong>最左前缀原则是什么</strong></h2><p>当一个SQL想要利用索引是，就一定要提供该索引所对应的字段中最左边的字段，也就是排在最前面的字段，比如针对a,b,c三个字段建立了一个联合索引，那么在写一个sql时就一定要提供a字段的条件，这样才能用到联合索引，这是由于在建立a,b,c三个字段的联合索引时，底层的B+树是按照a,b,c三个字段从左往右去比较大小进行排序的，所以如果想要利用B+树进行快速查找也得符合这个规则</p><h2 id="Innodb是如何实现事务的"><a href="#Innodb是如何实现事务的" class="headerlink" title="Innodb是如何实现事务的"></a><strong>Innodb是如何实现事务的</strong></h2><p>Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以一个update语句为例：</p><ol><li>Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中</li><li>执行update语句，修改Buffer Pool中的数据，也就是内存中的数据</li><li>针对update语句生成一个RedoLog对象，并存入LogBuffer中</li><li>针对update语句生成undolog日志，用于事务回滚</li><li>如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中</li><li>如果事务回滚，则利用undolog日志进行回滚</li></ol><h2 id="B树和B-树的区别，为什么Mysql使用B-树"><a href="#B树和B-树的区别，为什么Mysql使用B-树" class="headerlink" title="B树和B+树的区别，为什么Mysql使用B+树"></a><strong>B树和B+树的区别，为什么Mysql使用B+树</strong></h2><p>B树的特点：</p><ol><li>节点排序</li><li>一个节点了可以存多个元素，多个元素也排序了</li></ol><p>B+树的特点：</p><ol><li>拥有B树的特点</li><li>叶子节点之间有指针</li><li>非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序</li></ol><p>Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在Mysql中一个Innodb页就是一个B+树节点，一个Innodb页默认16kb，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。</p><h2 id="Mysql锁有哪些，如何理解"><a href="#Mysql锁有哪些，如何理解" class="headerlink" title="Mysql锁有哪些，如何理解"></a><strong>Mysql锁有哪些，如何理解</strong></h2><p>按锁粒度分类：</p><ol><li>行锁：锁某行数据，锁粒度最小，并发度高</li><li>表锁：锁整张表，锁粒度最大，并发度低</li><li>间隙锁：锁的是一个区间</li></ol><p>还可以分为：</p><ol><li>共享锁：也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写</li><li>排它锁：也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写</li></ol><p>还可以分为：</p><ol><li>乐观锁：并不会真正的去锁某行记录，而是通过一个版本号来实现的</li><li>悲观锁：上面所的行锁、表锁等都是悲观锁</li></ol><p>在事务的隔离级别实现中，就需要利用锁来解决幻读</p><h2 id="Mysql慢查询该如何优化？"><a href="#Mysql慢查询该如何优化？" class="headerlink" title="Mysql慢查询该如何优化？"></a><strong>Mysql慢查询该如何优化？</strong></h2><ol><li>检查是否走了索引，如果没有则优化SQL利用索引</li><li>检查所利用的索引，是否是最优索引</li><li>检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据</li><li>检查表中数据是否过多，是否应该进行分库分表了</li><li>检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源</li></ol><h2 id="什么是RDB和AOF"><a href="#什么是RDB和AOF" class="headerlink" title="什么是RDB和AOF"></a><strong>什么是RDB和AOF</strong></h2><p>RDB：Redis DataBase，在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。<br><strong>优点：</strong></p><ol><li>整个Redis数据库将只包含一个文件 dump.rdb，方便持久化。</li><li>容灾性好，方便备份。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ol><p><strong>缺点：</strong></p><ol><li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li></ol><p>AOF：Append Only File，以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录<br><strong>优点：</strong></p><ol><li>数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。。</li><li>通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>AOF 机制的 rewrite 模式。定期对AOF文件进行重写，以达到压缩的目的</li></ol><p>缺点：</p><ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低。</li><li>运行效率没有RDB高</li></ol><p>AOF文件比RDB更新频率高，优先使用AOF还原数据，AOF比RDB更安全也更大，RDB性能比AOF好，如果两个都配了优先加载AOF。</p><h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a><strong>Redis的过期键的删除策略</strong></h2><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p><ul><li><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li><li><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li></ul><p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p><p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p><h2 id="简述Redis事务实现"><a href="#简述Redis事务实现" class="headerlink" title="简述Redis事务实现"></a><strong>简述Redis事务实现</strong></h2><p><strong>1、事务开始</strong></p><p>_MULTI_命令的执行，标识着一个事务的开始。_MULTI_命令会将客户端状态的flags属性中打开REDIS_MULTI标识来完成的。</p><p><strong>2、命令入队</strong></p><p>当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为_MULTI_、_EXEC_、_WATCH_、_DISCARD_中的一个，立即执行这个命令，否则将命令放入一个事务队列里面，然后向客户端返回QUEUED回复</p><ul><li>如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。</li><li>如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。 首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。 如果正确，将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复</li></ul><p>事务队列是按照FIFO的方式保存入队的命令<br><strong>3、事务执行</strong></p><p>客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑。</p><ul><li>如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者 REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行。</li><li>否则客户端处于事务状态（flags 有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端</li></ul><p>Redis 不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。</p><p>Redis 事务不支持检查那些程序员自己逻辑错误。例如对 String 类型的数据库键执行对 HashMap 类型的操作！</p><ul><li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li><li>MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li><li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。</li><li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li><li>UNWATCH命令可以取消watch对所有key的监控。</li></ul><h2 id="Redis-主从复制的核心原理"><a href="#Redis-主从复制的核心原理" class="headerlink" title="Redis 主从复制的核心原理"></a><strong>Redis 主从复制的核心原理</strong></h2><p>通过执行slaveof命令或设置slaveof选项，让一个服务器去复制另一个服务器的数据。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。</p><p>全量复制：</p><ol><li>主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的</li><li>主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</li><li>从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗</li></ol><p>部分复制：</p><ol><li>复制偏移量：执行复制的双方，主从节点，分别会维护一个复制偏移量offset</li><li>复制积压缓冲区：主节点内部维护了一个固定长度的、先进先出(FIFO)队列 作为复制积压缓冲区，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</li><li>服务器运行ID(runid)：每个Redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点，从节点会将主节点的运行ID存起来。 从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度：<ol><li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)</li><li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制</li></ol></li></ol><h2 id="Redis有哪些数据结构？分别有哪些典型的应用场景？"><a href="#Redis有哪些数据结构？分别有哪些典型的应用场景？" class="headerlink" title="Redis有哪些数据结构？分别有哪些典型的应用场景？"></a><strong>Redis有哪些数据结构？分别有哪些典型的应用场景？</strong></h2><p>Redis的数据结构有：</p><ol><li>字符串：可以用来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</li><li>哈希表：可以用来存储一些key-value对，更适合用来存储对象</li><li>列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据</li><li>集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似，我和某人共同关注的人、朋友圈点赞等功能</li><li>有序集合：集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能</li></ol><h2 id="Redis分布式锁底层是如何实现的？"><a href="#Redis分布式锁底层是如何实现的？" class="headerlink" title="Redis分布式锁底层是如何实现的？"></a><strong>Redis分布式锁底层是如何实现的？</strong></h2><ol><li>首先利用setnx来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁</li><li>然后还要利用lua脚本来保证多个redis操作的原子性</li><li>同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约</li><li>同时还要考虑到redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N&#x2F;2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到</li></ol><h2 id="Redis主从复制的核心原理"><a href="#Redis主从复制的核心原理" class="headerlink" title="Redis主从复制的核心原理"></a><strong>Redis主从复制的核心原理</strong></h2><p>Redis的主从复制是提高Redis的可靠性的有效措施，主从复制的流程如下：</p><ol><li>集群启动时，主从库间会先建立连接，为全量复制做准备</li><li>主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载，这个过程依赖于内存快照RDB</li><li>在主库将数据同步给从库的过程中，主库不会阻塞，仍然可以正常接收请求。否则，redis的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的RDB文件中。为了保证主从库的数据一致性，主库会在内存中用专门的replication buffer，记录RDB文件生成收到的所有写操作。</li><li>最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成RDB文件发送后，就会把此时replocation buffer中修改操作发送给从库，从库再执行这些操作。这样一来，主从库就实现同步了</li><li>后续主库和从库都可以处理客户端读操作，写操作只能交给主库处理，主库接收到写操作后，还会将写操作发送给从库，实现增量同步</li></ol><h2 id="Redis集群策略"><a href="#Redis集群策略" class="headerlink" title="Redis集群策略"></a><strong>Redis集群策略</strong></h2><p>Redis提供了三种集群策略：</p><ol><li>主从模式：这种模式比较简单，主库可以读写，并且会和从库进行数据同步，这种模式下，客户端直接连主库或某个从库，但是但主库或从库宕机后，客户端需要手动修改IP，另外，这种模式也比较难进行扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能支持特大数据量</li><li>哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择一个库作为进的主库，另外哨兵也可以做集群，从而可以保证但某一个哨兵节点宕机后，还有其他哨兵节点可以继续工作，这种模式可以比较好的保证Redis集群的高可用，但是仍然不能很好的解决Redis的容量上限问题。</li><li>Cluster模式：Cluster模式是用得比较多的模式，它支持多主多从，这种模式会按照key进行槽位的分配，可以使得不同的key分散到不同的主节点上，利用这种模式可以使得整个集群支持更大的数据容量，同时每个主节点可以拥有自己的多个从节点，如果该主节点宕机，会从它的从节点中选举一个新的主节点。</li></ol><p>对于这三种模式，如果Redis要存的数据量不大，可以选择哨兵模式，如果Redis要存的数据量大，并且需要持续的扩容，那么选择Cluster模式。</p><h2 id="缓存穿透、缓存击穿、缓存雪崩分别是什么"><a href="#缓存穿透、缓存击穿、缓存雪崩分别是什么" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩分别是什么"></a><strong>缓存穿透、缓存击穿、缓存雪崩分别是什么</strong></h2><p>缓存中存放的大多都是热点数据，目的就是防止请求可以直接从缓存中获取到数据，而不用访问Mysql。</p><ol><li>缓存雪崩：如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问Mysql了，解决办法就是在过期时间上增加一点随机值，另外如果搭建一个高可用的Redis集群也是防止缓存雪崩的有效手段</li><li>缓存击穿：和缓存雪崩类似，缓存雪崩是大批热点数据失效，而缓存击穿是指某一个热点key突然失效，也导致了大量请求直接访问Mysql数据库，这就是缓存击穿，解决方案就是考虑这个热点key不设过期时间</li><li>缓存穿透：假如某一时刻访问redis的大量key都在redis中不存在（比如黑客故意伪造一些乱七八糟的key），那么也会给数据造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加一层布隆过滤器来拦截不存在的key</li></ol><h2 id="Redis和Mysql如何保证数据一致"><a href="#Redis和Mysql如何保证数据一致" class="headerlink" title="Redis和Mysql如何保证数据一致"></a><strong>Redis和Mysql如何保证数据一致</strong></h2><ol><li>先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不一致</li><li>先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新Mysql，此时另外一个查询再查询，那么就会把Mysql中老数据又查到Redis中</li><li>延时双删，步骤是：先删除Redis缓存数据，再更新Mysql，延迟几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把老数据读到了Redis中，那么也会被删除掉，从而把数据保持一致</li></ol><h2 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a><strong>Redis的持久化机制</strong></h2><p>RDB：Redis DataBase 将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘。<br>手动触发：</p><ul><li>save命令，使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用</li><li>bgsave命令，fork出一个子进程执行持久化，主进程只在fork过程中有短暂的阻塞，子进程创建之后，主进程就可以响应客户端请求了</li><li>自动触发：</li><li>save m n ：在 m 秒内，如果有 n 个键发生改变，则自动触发持久化，通过bgsave执行，如果设置多个、只要满足其一就会触发，配置文件有默认配置(可以注释掉)</li><li>flushall：用于清空redis所有的数据库，flushdb清空当前redis所在库数据(默认是0号数据库)，会清空RDB文件，同时也会生成dump.rdb、内容为空</li><li>主从同步：全量同步时会自动触发bgsave命令，生成rdb发送给从节点</li></ul><p>优点：</p><ol><li>整个Redis数据库将只包含一个文件 dump.rdb，方便持久化。</li><li>容灾性好，方便备份。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li><li>相对于数据集大时，比 AOF的启动效率更高。</li></ol><p>缺点：</p><ol><li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。会占用cpu</li></ol><p>AOF：Append Only File 以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录，调操作系统命令进程刷盘</p><ol><li>所有的写命令会追加到 AOF 缓冲中。</li><li>AOF 缓冲区根据对应的策略向硬盘进行同步操作。</li><li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li><li>当 Redis 重启时，可以加载 AOF 文件进行数据恢复。同步策略：</li></ol><p>每秒同步：异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失<br>每修改同步：同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢一条 不同步：由操作系统控制，可能丢失较多数据<br>优点：</p><ol><li>数据安全</li><li>通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis- check-aof 工具解决数据一致性问题。</li><li>AOF 机制的 rewrite 模式。定期对AOF文件进行重写，以达到压缩的目的</li></ol><p>缺点：</p><ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低。</li><li>运行效率没有RDB高</li></ol><p>对比：</p><ul><li>AOF文件比RDB更新频率高，优先使用AOF还原数据。AOF比RDB更安全也更大</li><li>RDB性能比AOF好</li><li>如果两个都配了优先加载AOF</li></ul><h2 id="Redis单线程为什么这么快"><a href="#Redis单线程为什么这么快" class="headerlink" title="Redis单线程为什么这么快"></a><strong>Redis单线程为什么这么快</strong></h2><p>Redis基于Reactor模式开发了网络事件处理器、文件事件处理器 fileeventhandler。它是单线程的， 所以 Redis才叫做单线程的模型，它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis内部的线程模型的简单性。<br>文件事件处理器的结构包含4个部分：多个Socket、IO多路复用程序、文件事件分派器以及事件处理器<br>（命令请求处理器、命令回复处理器、连接应答处理器等）。<br>多个 Socket 可能并发的产生不同的事件，IO多路复用程序会监听多个 Socket，会将 Socket 放入一个队列中排队，每次从队列中有序、同步取出一个 Socket 给事件分派器，事件分派器把 Socket 给对应的事件处理器。<br>然后一个 Socket 的事件处理完之后，IO多路复用程序才会将队列中的下一个 Socket 给事件分派器。文件事件分派器会根据每个 Socket 当前产生的事件，来选择对应的事件处理器来处理。</p><ol><li>Redis启动初始化时，将连接应答处理器跟AE_READABLE事件关联。</li><li>若一个客户端发起连接，会产生一个AE_READABLE事件，然后由连接应答处理器负责和客户端建立 连接，创建客户端对应的socket，同时将这个socket的AE_READABLE事件和命令请求处理器关联，使 得客户端可以向主服务器发送命令请求。</li><li>当客户端向Redis发请求时（不管读还是写请求），客户端socket都会产生一个AE_READABLE事件，触发命令请求处理器。处理器读取客户端的命令内容， 然后传给相关程序执行。</li><li>当Redis服务器准备好给客户端的响应数据后，会将socket的AE_WRITABLE事件和命令回复处理器关联，当客户端准备好读取响应数据时，会在socket产生一个AE_WRITABLE事件，由对应命令回复处 理器处理，即将准备好的响应数据写入socket，供客户端读取。</li><li>命令回复处理器全部写完到 socket 后，就会删除该socket的AE_WRITABLE事件和命令回复处理器的映射。</li></ol><p>单线程快的原因：</p><ol><li>纯内存操作</li><li>核心是基于非阻塞的IO多路复用机制</li><li>单线程反而避免了多线程的频繁上下文切换带来的性能问题</li></ol><h2 id="简述Redis事务实现-1"><a href="#简述Redis事务实现-1" class="headerlink" title="简述Redis事务实现"></a><strong>简述Redis事务实现</strong></h2><ul><li>事务开始：MULTI命令的执行，标识着一个事务的开始。MULTI命令会将客户端状态的 flags属性中打开REDIS_MULTI标识来完成的。</li><li>命令入队：当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客 户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的一个，立即执行这个命令，否则将命令放入一 个事务队列里面，然后向客户端返回QUEUED回复，如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。如果正确，将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复事务队列是按照FIFO的方式保存入队的命令</li><li>事务执行：客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑。如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行。 否则客户端处于事务状态（flags有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；Redis不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。Redis事务不支持检查那些程序员自己逻辑错误。例如对 String 类型的数据库键执行对 HashMap 类型的操作！</li></ul><h2 id="什么是CAP理论"><a href="#什么是CAP理论" class="headerlink" title="什么是CAP理论"></a><strong>什么是CAP理论</strong></h2><p>CAP理论是分布式领域中非常重要的一个指导理论，C（Consistency）表示强一致性，A（Availability）表示可用性，P（Partition Tolerance）表示分区容错性，CAP理论指出在目前的硬件条件下，一个分布式系统是必须要保证分区容错性的，而在这个前提下，分布式系统要么保证CP，要么保证AP，无法同时保证CAP。</p><p>分区容错性表示，一个系统虽然是分布式的，但是对外看上去应该是一个整体，不能由于分布式系统内部的某个结点挂点，或网络出现了故障，而导致系统对外出现异常。所以，对于分布式系统而言是一定要保证分区容错性的。</p><p>强一致性表示，一个分布式系统中各个结点之间能及时的同步数据，在数据同步过程中，是不能对外提供服务的，不然就会造成数据不一致，所以强一致性和可用性是不能同时满足的。</p><p>可用性表示，一个分布式系统对外要保证可用。</p><h2 id="什么是BASE理论"><a href="#什么是BASE理论" class="headerlink" title="什么是BASE理论"></a><strong>什么是BASE理论</strong></h2><p>由于不能同时满足CAP，所以出现了BASE理论：</p><ol><li>BA：Basically Available，表示基本可用，表示可以允许一定程度的不可用，比如由于系统故障，请求时间变长，或者由于系统故障导致部分非核心功能不可用，都是允许的</li><li>S：Soft state：表示分布式系统可以处于一种中间状态，比如数据正在同步</li><li>E：Eventually consistent，表示最终一致性，不要求分布式系统数据实时达到一致，允许在经过一段时间后再达到一致，在达到一致过程中，系统也是可用的</li></ol><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a><strong>什么是RPC</strong></h2><p>RPC，表示远程过程调用，对于Java这种面试对象语言，也可以理解为远程方法调用，RPC调用和HTTP调用是有区别的，RPC表示的是一种调用远程方法的方式，可以使用HTTP协议、或直接基于TCP协议来实现RPC，在Java中，我们可以通过直接使用某个服务接口的代理对象来执行方法，而底层则通过构造HTTP请求来调用远端的方法，所以，有一种说法是RPC协议是HTTP协议之上的一种协议，也是可以理解的。</p><h2 id="数据一致性模型有哪些"><a href="#数据一致性模型有哪些" class="headerlink" title="数据一致性模型有哪些"></a><strong>数据一致性模型有哪些</strong></h2><ul><li>强一致性：当更新操作完成之后，任何多个后续进程的访问都会返回最新的更新过的值，这种是对用户 最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP理论，这种实现需要牺牲可用性。</li><li>弱一致性：系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。用户读到某一操作对系统数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</li><li>最终一致性：最终一致性是弱一致性的特例，强调的是所有的数据副本，在经过一段时间的同步之后， 最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。到达最终一致性的时间，就是不一致窗口时间，在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。最终一致性模型根据其提供的不同保证可以划分为更多的模型，包括因果一致性和会话一致性等。</li></ul><h2 id="分布式ID是什么？有哪些解决方案？"><a href="#分布式ID是什么？有哪些解决方案？" class="headerlink" title="分布式ID是什么？有哪些解决方案？"></a><strong>分布式ID是什么？有哪些解决方案？</strong></h2><p>在开发中，我们通常会需要一个唯一ID来标识数据，如果是单体架构，我们可以通过数据库的主键，或直接在内存中维护一个自增数字来作为ID都是可以的，但对于一个分布式系统，就会有可能会出现ID冲突，此时有以下解决方案：</p><ol><li>uuid，这种方案复杂度最低，但是会影响存储空间和性能</li><li>利用单机数据库的自增主键，作为分布式ID的生成器，复杂度适中，ID长度较之uuid更短，但是受到单机数据库性能的限制，并发量大的时候，此方案也不是最优方案</li><li>利用redis、zookeeper的特性来生成id，比如redis的自增命令、zookeeper的顺序节点，这种方案和单机数据库(mysql)相比，性能有所提高，可以适当选用</li><li>雪花算法，一切问题如果能直接用算法解决，那就是最合适的，利用雪花算法也可以生成分布式ID，底层原理就是通过某台机器在某一毫秒内对某一个数字自增，这种方案也能保证分布式架构中的系统id唯一，但是只能保证趋势递增。业界存在tinyid、leaf等开源中间件实现了雪花算法。</li></ol><h2 id="分布式锁的使用场景是什么？有哪些实现方案？"><a href="#分布式锁的使用场景是什么？有哪些实现方案？" class="headerlink" title="分布式锁的使用场景是什么？有哪些实现方案？"></a><strong>分布式锁的使用场景是什么？有哪些实现方案？</strong></h2><p>在单体架构中，多个线程都是属于同一个进程的，所以在线程并发执行时，遇到资源竞争时，可以利用ReentrantLock、synchronized等技术来作为锁，来控制共享资源的使用。</p><p>而在分布式架构中，多个线程是可能处于不同进程中的，而这些线程并发执行遇到资源竞争时，利用ReentrantLock、synchronized等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思就是，需要一个分布式锁生成器，分布式系统中的应用程序都可以来使用这个生成器所提供的锁，从而达到多个进程中的线程使用同一把锁。</p><p>目前主流的分布式锁的实现方案有两种：</p><ol><li>zookeeper：利用的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式锁的特点是高一致性，因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱</li><li>redis：利用redis的setnx、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是高可用，因为redis保证的是AP，所以由它实现的分布式锁可能不可靠，不稳定（一旦redis中的数据出现了不一致），可能会出现多个客户端同时加到锁的情况</li></ol><h2 id="什么是分布式事务？有哪些实现方案？"><a href="#什么是分布式事务？有哪些实现方案？" class="headerlink" title="什么是分布式事务？有哪些实现方案？"></a><strong>什么是分布式事务？有哪些实现方案？</strong></h2><p>在分布式系统中，一次业务处理可能需要多个应用来实现，比如用户发送一次下单请求，就涉及到订单系统创建订单、库存系统减库存，而对于一次下单，订单创建与减库存应该是要同时成功或同时失败的，但在分布式系统中，如果不做处理，就很有可能出现订单创建成功，但是减库存失败，那么解决这类问题，就需要用到分布式事务。常用解决方案有：</p><ol><li>本地消息表：创建订单时，将减库存消息加入在本地事务中，一起提交到数据库存入本地消息表，然后调用库存系统，如果调用成功则修改本地消息状态为成功，如果调用库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调用库存系统</li><li>消息队列：目前RocketMQ中支持事务消息，它的工作原理是：<ol><li>生产者订单系统先发送一条half消息到Broker，half消息对消费者而言是不可见的</li><li>再创建订单，根据创建订单成功与否，向Broker发送commit或rollback</li><li>并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功</li><li>一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束</li><li>如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理</li></ol></li><li>Seata：阿里开源的分布式事务框架，支持AT、TCC等多种模式，底层都是基于两阶段提交理论来实现的</li></ol><h2 id="什么是ZAB协议"><a href="#什么是ZAB协议" class="headerlink" title="什么是ZAB协议"></a><strong>什么是ZAB协议</strong></h2><p>ZAB协议是Zookeeper用来实现一致性的原子广播协议，该协议描述了Zookeeper是如何实现一致性的，分为三个阶段：</p><ol><li>领导者选举阶段：从Zookeeper集群中选出一个节点作为Leader，所有的写请求都会由Leader节点来处理</li><li>数据同步阶段：集群中所有节点中的数据要和Leader节点保持一致，如果不一致则要进行同步</li><li>请求广播阶段：当Leader节点接收到写请求时，会利用两阶段提交来广播该写请求，使得写请求像事务一样在其他节点上执行，达到节点上的数据实时一致</li></ol><p>但值得注意的是，Zookeeper只是尽量的在达到强一致性，实际上仍然只是最终一致性的。</p><h2 id="为什么Zookeeper可以用来作为注册中心"><a href="#为什么Zookeeper可以用来作为注册中心" class="headerlink" title="为什么Zookeeper可以用来作为注册中心"></a><strong>为什么Zookeeper可以用来作为注册中心</strong></h2><p>可以利用Zookeeper的临时节点和watch机制来实现注册中心的自动注册和发现，另外Zookeeper中的数据都是存在内存中的，并且Zookeeper底层采用了nio，多线程模型，所以Zookeeper的性能也是比较高的，所以可以用来作为注册中心，但是如果考虑到注册中心应该是注册可用性的话，那么Zookeeper则不太合适，因为Zookeeper是CP的，它注重的是一致性，所以集群数据不一致时，集群将不可用，所以用Redis、Eureka、Nacos来作为注册中心将更合适。</p><h2 id="Zookeeper中的领导者选举的流程是怎样的？"><a href="#Zookeeper中的领导者选举的流程是怎样的？" class="headerlink" title="Zookeeper中的领导者选举的流程是怎样的？"></a><strong>Zookeeper中的领导者选举的流程是怎样的？</strong></h2><p>对于Zookeeper集群，整个集群需要从集群节点中选出一个节点作为Leader，大体流程如下：</p><ol><li>集群中各个节点首先都是观望状态（LOOKING），一开始都会投票给自己，认为自己比较适合作为leader</li><li>然后相互交互投票，每个节点会收到其他节点发过来的选票，然后pk，先比较zxid，zxid大者获胜，zxid如果相等则比较myid，myid大者获胜</li><li>一个节点收到其他节点发过来的选票，经过PK后，如果PK输了，则改票，此节点就会投给zxid或myid更大的节点，并将选票放入自己的投票箱中，并将新的选票发送给其他节点</li><li>如果pk是平局则将接收到的选票放入自己的投票箱中</li><li>如果pk赢了，则忽略所接收到的选票</li><li>当然一个节点将一张选票放入到自己的投票箱之后，就会从投票箱中统计票数，看是否超过一半的节点都和自己所投的节点是一样的，如果超过半数，那么则认为当前自己所投的节点是leader</li><li>集群中每个节点都会经过同样的流程，pk的规则也是一样的，一旦改票就会告诉给其他服务器，所以最终各个节点中的投票箱中的选票也将是一样的，所以各个节点最终选出来的leader也是一样的，这样集群的leader就选举出来了</li></ol><h2 id="Zookeeper集群中节点之间数据是如何同步的"><a href="#Zookeeper集群中节点之间数据是如何同步的" class="headerlink" title="Zookeeper集群中节点之间数据是如何同步的"></a><strong>Zookeeper集群中节点之间数据是如何同步的</strong></h2><ol><li>首先集群启动时，会先进行领导者选举，确定哪个节点是Leader，哪些节点是Follower和Observer</li><li>然后Leader会和其他节点进行数据同步，采用发送快照和发送Diff日志的方式</li><li>集群在工作过程中，所有的写请求都会交给Leader节点来进行处理，从节点只能处理读请求</li><li>Leader节点收到一个写请求时，会通过两阶段机制来处理</li><li>Leader节点会将该写请求对应的日志发送给其他Follower节点，并等待Follower节点持久化日志成功</li><li>Follower节点收到日志后会进行持久化，如果持久化成功则发送一个Ack给Leader节点</li><li>当Leader节点收到半数以上的Ack后，就会开始提交，先更新Leader节点本地的内存数据</li><li>然后发送commit命令给Follower节点，Follower节点收到commit命令后就会更新各自本地内存数据</li><li>同时Leader节点还是将当前写请求直接发送给Observer节点，Observer节点收到Leader发过来的写请求后直接执行更新本地内存数据</li><li>最后Leader节点返回客户端写请求响应成功</li><li>通过同步机制和两阶段提交机制来达到集群中节点数据一致</li></ol><h2 id="Dubbo支持哪些负载均衡策略"><a href="#Dubbo支持哪些负载均衡策略" class="headerlink" title="Dubbo支持哪些负载均衡策略"></a><strong>Dubbo支持哪些负载均衡策略</strong></h2><ol><li>随机：从多个服务提供者随机选择一个来处理本次请求，调用量越大则分布越均匀，并支持按权重设置随机概率</li><li>轮询：依次选择服务提供者来处理请求， 并支持按权重进行轮询，底层采用的是平滑加权轮询算法</li><li>最小活跃调用数：统计服务提供者当前正在处理的请求，下次请求过来则交给活跃数最小的服务器来处理</li><li>一致性哈希：相同参数的请求总是发到同一个服务提供者</li></ol><h2 id="Dubbo是如何完成服务导出的？"><a href="#Dubbo是如何完成服务导出的？" class="headerlink" title="Dubbo是如何完成服务导出的？"></a><strong>Dubbo是如何完成服务导出的？</strong></h2><ol><li>首先Dubbo会将程序员所使用的@DubboService注解或@Service注解进行解析得到程序员所定义的服务参数，包括定义的服务名、服务接口、服务超时时间、服务协议等等，得到一个ServiceBean。</li><li>然后调用ServiceBean的export方法进行服务导出</li><li>然后将服务信息注册到注册中心，如果有多个协议，多个注册中心，那就将服务按单个协议，单个注册中心进行注册</li><li>将服务信息注册到注册中心后，还会绑定一些监听器，监听动态配置中心的变更</li><li>还会根据服务协议启动对应的Web服务器或网络框架，比如Tomcat、Netty等</li></ol><h2 id="Dubbo是如何完成服务引入的？"><a href="#Dubbo是如何完成服务引入的？" class="headerlink" title="Dubbo是如何完成服务引入的？"></a><strong>Dubbo是如何完成服务引入的？</strong></h2><ol><li>当程序员使用@Reference注解来引入一个服务时，Dubbo会将注解和服务的信息解析出来，得到当前所引用的服务名、服务接口是什么</li><li>然后从注册中心进行查询服务信息，得到服务的提供者信息，并存在消费端的服务目录中</li><li>并绑定一些监听器用来监听动态配置中心的变更</li><li>然后根据查询得到的服务提供者信息生成一个服务接口的代理对象，并放入Spring容器中作为Bean</li></ol><h2 id="Dubbo的架构设计是怎样的？"><a href="#Dubbo的架构设计是怎样的？" class="headerlink" title="Dubbo的架构设计是怎样的？"></a><strong>Dubbo的架构设计是怎样的？</strong></h2><p>Dubbo中的架构设计是非常优秀的，分为了很多层次，并且每层都是可以扩展的，比如：</p><ol><li>Proxy服务代理层，支持JDK动态代理、javassist等代理机制</li><li>Registry注册中心层，支持Zookeeper、Redis等作为注册中心</li><li>Protocol远程调用层，支持Dubbo、Http等调用协议</li><li>Transport网络传输层，支持netty、mina等网络传输框架</li><li>Serialize数据序列化层，支持JSON、Hessian等序列化机制</li></ol><p><strong>各层说明：</strong></p><ul><li><strong>config 配置层</strong>：对外配置接口，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code>为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li><li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 <code>ServiceProxy</code> 为中心，扩展接口为 <code>ProxyFactory</code></li><li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <code>RegistryFactory</code>, <code>Registry</code>, <code>RegistryService</code></li><li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code>为中心，扩展接口为 <code>Cluster</code>, <code>Directory</code>, <code>Router</code>, <code>LoadBalance</code></li><li><strong>monitor监控层</strong>：RPC调用次数和调用时间监控，以<code>Statistics</code>为中心，扩展接口为<code>MonitorFactory</code>, <code>Monitor</code>, <code>MonitorService</code></li><li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以<code>Invocation</code>, <code>Result</code>为中心，扩展接口为<code>Protocol</code>, <code>Invoker</code>, <code>Exporter</code></li><li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心，扩展接口为 <code>Exchanger</code>, <code>ExchangeChannel</code>, <code>ExchangeClient</code>, <code>ExchangeServer</code></li><li><strong>transport 网络传输层</strong>：抽象<code>mina</code>和<code>netty</code>为统一接口，以<code>Message</code>为中心，扩展接口为<code>Channel</code>, <code>Transporter</code>, <code>Client</code>, <code>Server</code>, <code>Codec</code></li><li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 <code>Serialization</code>, <code>ObjectInput</code>, <code>ObjectOutput</code>, <code>ThreadPool</code></li></ul><p><strong>关系说明</strong></p><ul><li>在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</li><li>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。</li><li>而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</li><li>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li><li>而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</li><li>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</li></ul><p><img src="/2023-02-26-5496f818735c/dubbo-framework.jpg"></p><h2 id="负载均衡算法有哪些"><a href="#负载均衡算法有哪些" class="headerlink" title="负载均衡算法有哪些"></a><strong>负载均衡算法有哪些</strong></h2><ol><li><strong>轮询法：</strong>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li><li><strong>随机法：</strong>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</li><li><strong>源地址哈希法：</strong>源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li><li><strong>加权轮询法：</strong>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li><li><strong>加权随机法：</strong>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</li><li><strong>最小连接数法：</strong>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li></ol><h2 id="分布式架构下，Session-共享有什么方案"><a href="#分布式架构下，Session-共享有什么方案" class="headerlink" title="分布式架构下，Session 共享有什么方案"></a><strong>分布式架构下，Session 共享有什么方案</strong></h2><ol><li>采用无状态服务，抛弃session</li><li>存入cookie（有安全风险）</li><li>服务器之间进行 Session 同步，这样可以保证每个服务器上都有全部的 Session 信息，不过当服务器数量比较多的时候，同步是会有延迟甚至同步失败；</li><li>IP 绑定策略<br>使用 Nginx （或其他复杂均衡软硬件）中的 IP 绑定策略，同一个 IP 只能在指定的同一个机器访问，但是这样做失去了负载均衡的意义，当挂掉一台服务器的时候，会影响一批用户的使用，风险很大；</li><li>使用 Redis 存储</li></ol><p>把 Session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：</p><ul><li>实现了 Session 共享；</li><li>可以水平扩展（增加 Redis 服务器）；</li><li>服务器重启 Session 不丢失（不过也要注意 Session 在 Redis 中的刷新&#x2F;失效机制）；</li><li>不仅可以跨服务器 Session 共享，甚至可以跨平台（例如网页端和 APP 端）。</li></ul><h2 id="如何实现接口的幂等性"><a href="#如何实现接口的幂等性" class="headerlink" title="如何实现接口的幂等性"></a><strong>如何实现接口的幂等性</strong></h2><ul><li>唯一id。每次操作，都根据操作和内容生成唯一的id，在执行之前先判断id是否存在，如果不存在则执行后续操作，并且保存到数据库或者redis等。</li><li>服务端提供发送token的接口，业务调用接口前先获取token,然后调用业务接口请求时，把token携带过去,务器判断token是否存在redis中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把redis中的token删除</li><li>建去重表。将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了</li><li>版本控制。增加版本号，当版本号符合时，才能更新数据</li><li>状态控制。例如订单有状态已支付 未支付 支付中 支付失败，当处于未支付的时候才允许修改为支付中等</li></ul><h2 id="简述zk的命名服务、配置管理、集群管理"><a href="#简述zk的命名服务、配置管理、集群管理" class="headerlink" title="简述zk的命名服务、配置管理、集群管理"></a><strong>简述zk的命名服务、配置管理、集群管理</strong></h2><p>命名服务：<br>通过指定的名字来获取资源或者服务地址。Zookeeper可以创建一个全局唯一的路径，这个路径就可以作为一个名字。被命名的实体可以是集群中的机器，服务的地址，或者是远程的对象等。一些分布式服务框架（RPC、RMI）中的服务地址列表，通过使用命名服务，客户端应用能够根据特定的名字来获取资源的实体、服务地址和提供者信息等</p><p>配置管理：<br>实际项目开发中，经常使用.properties或者xml需要配置很多信息，如数据库连接信息、fps地址端口等等。程序分布式部署时，如果把程序的这些配置信息保存在zk的znode节点下，当你要修改配置，即znode会发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。</p><p>集群管理：<br>集群管理包括集群监控和集群控制，就是监控集群机器状态，剔除机器和加入机器。zookeeper可以方便集群机器的管理，它可以实时监控znode节点的变化，一旦发现有机器挂了，该机器就会与zk断开连接，对应的临时目录节点会被删除，其他所有机器都收到通知。新机器加入也是类似。</p><h2 id="讲下Zookeeper中的watch机制"><a href="#讲下Zookeeper中的watch机制" class="headerlink" title="讲下Zookeeper中的watch机制"></a><strong>讲下Zookeeper中的watch机制</strong></h2><p>客户端，可以通过在znode上设置watch，实现实时监听znode的变化<br>Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端</p><ul><li>父节点的创建，修改，删除都会触发Watcher事件。</li><li>子节点的创建，删除会触发Watcher事件。</li></ul><p>一次性：一旦被触发就会移除，再次使用需要重新注册，因为每次变动都需要通知所有客户端，一次性可以减轻压力，3.6.0默认持久递归，可以触发多次<br>轻量：只通知发生了事件，不会告知事件内容，减轻服务器和带宽压力<br>Watcher 机制包括三个角色：客户端线程、客户端的 WatchManager 以及 ZooKeeper 服务器</p><ol><li>客户端向 ZooKeeper 服务器注册一个 Watcher 监听， </li><li>把这个监听信息存储到客户端的 WatchManager 中 </li><li>当 ZooKeeper 中的节点发生变化时，会通知客户端，客户端会调用相应 Watcher 对象中的回调方法。watch回调是串行同步的</li></ol><h2 id="Zookeeper和Eureka的区别"><a href="#Zookeeper和Eureka的区别" class="headerlink" title="Zookeeper和Eureka的区别"></a><strong>Zookeeper和Eureka的区别</strong></h2><p>zk：CP设计(强一致性)，目标是一个分布式的协调系统，用于进行资源的统一管理。<br>当节点crash后，需要进行leader的选举，在这个期间内，zk服务是不可用的。<br>eureka：AP设计（高可用），目标是一个服务注册发现系统，专门用于微服务的服务发现注册。<br>Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时如果发现连接失败，会自动切换至其他节点，只要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）<br>同时当eureka的服务端发现85%以上的服务都没有心跳的话，它就会认为自己的网络出了问题，就不会从服务列表中删除这些失去心跳的服务，同时eureka的客户端也会缓存服务信息。eureka对于服务注册发现来说是非常好的选择。</p><h2 id="存储拆分后如何解决唯一主键问题"><a href="#存储拆分后如何解决唯一主键问题" class="headerlink" title="存储拆分后如何解决唯一主键问题"></a><strong>存储拆分后如何解决唯一主键问题</strong></h2><ul><li>UUID：简单、性能好，没有顺序，没有业务含义，存在泄漏mac地址的风险</li><li>数据库主键：实现简单，单调递增，具有一定的业务可读性，强依赖db、存在性能瓶颈，存在暴露业务 信息的风险</li><li>redis，mongodb，zk等中间件：增加了系统的复杂度和稳定性 </li><li>雪花算法</li></ul><h2 id="雪花算法原理"><a href="#雪花算法原理" class="headerlink" title="雪花算法原理"></a><strong>雪花算法原理</strong></h2><p>![](面试题全集&#x2F;image (1).png)<br>第一位符号位固定为0，41位时间戳，10位workId，12位序列号，位数可以有不同实现。<br>优点：每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳（依赖workId的实现）。时间戳值在高位，中间是固定的机器码，自增的序列在低位，整个ID是趋势递增的。能够根据业务场景数据库节点布置灵活调整bit位划分，灵活度高。<br>缺点：强依赖于机器时钟，如果时钟回拨，会导致重复的ID生成，所以一般基于此的算法发现时钟回 拨，都会抛异常处理，阻止ID生成，这可能导致服务不可用。</p><h2 id="如何解决不使用分区键的查询问题"><a href="#如何解决不使用分区键的查询问题" class="headerlink" title="如何解决不使用分区键的查询问题"></a><strong>如何解决不使用分区键的查询问题</strong></h2><ul><li>映射：将查询条件的字段与分区键进行映射，建一张单独的表维护(使用覆盖索引)或者在缓存中维 护</li><li>基因法：分区键的后x个bit位由查询字段进行hash后占用，分区键直接取x个bit位获取分区，查询字段进行hash获取分区，适合非分区键查询字段只有一个的情况</li><li>冗余：查询字段冗余存储</li></ul><h2 id="Spring-Cloud有哪些常用组件，作用是什么？"><a href="#Spring-Cloud有哪些常用组件，作用是什么？" class="headerlink" title="Spring Cloud有哪些常用组件，作用是什么？"></a><strong>Spring Cloud有哪些常用组件，作用是什么？</strong></h2><ol><li>Eureka：注册中心</li><li>Nacos：注册中心、配置中心</li><li>Consul：注册中心、配置中心</li><li>Spring Cloud Config：配置中心</li><li>Feign&#x2F;OpenFeign：RPC调用</li><li>Kong：服务网关</li><li>Zuul：服务网关</li><li>Spring Cloud Gateway：服务网关</li><li>Ribbon：负载均衡</li><li>Spring CLoud Sleuth：链路追踪</li><li>Zipkin：链路追踪</li><li>Seata：分布式事务</li><li>Dubbo：RPC调用</li><li>Sentinel：服务熔断</li><li>Hystrix：服务熔断</li></ol><h2 id="如何避免缓存穿透、缓存击穿、缓存雪崩？"><a href="#如何避免缓存穿透、缓存击穿、缓存雪崩？" class="headerlink" title="如何避免缓存穿透、缓存击穿、缓存雪崩？"></a><strong>如何避免缓存穿透、缓存击穿、缓存雪崩？</strong></h2><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。<br>解决方案：</p><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li><li>缓存预热互斥锁</li></ul><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。<br>解决方案：</p><ul><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户 反复用同一个id暴力攻击</li><li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li></ul><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。<br>解决方案：</p><ul><li>设置热点数据永远不过期。加互斥锁</li></ul><h2 id="分布式系统中常用的缓存方案有哪些"><a href="#分布式系统中常用的缓存方案有哪些" class="headerlink" title="分布式系统中常用的缓存方案有哪些"></a><strong>分布式系统中常用的缓存方案有哪些</strong></h2><ul><li>客户端缓存：页面和浏览器缓存，APP缓存，H5缓存，localStorage 和 sessionStorage CDN缓存：内容存储：数据的缓存，内容分发：负载均衡</li><li>nginx缓存：静态资源</li><li>服务端缓存：本地缓存，外部缓存</li><li>数据库缓存：持久层缓存（mybatis，hibernate多级缓存），mysql查询缓存 操作系统缓存：PageCache、BufferCache</li></ul><h2 id="缓存过期都有哪些策略？"><a href="#缓存过期都有哪些策略？" class="headerlink" title="缓存过期都有哪些策略？"></a><strong>缓存过期都有哪些策略？</strong></h2><ul><li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立 即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量</li><li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，但是很消耗内存、许多的过期数据都还存在内存中。极端情况可能出现大量的过期key没有 再次被访问，从而不会被清除，占用大量内存。</li><li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key（是随机的）， 并清除其中已过期的key。该策略是定时过期和惰性过期的折中方案。通过调整定时扫描的时间间隔和 每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li><li>分桶策略：定期过期的优化，将过期时间点相近的key放在一起，按时间扫描分桶。</li></ul><h2 id="常见的缓存淘汰算法"><a href="#常见的缓存淘汰算法" class="headerlink" title="常见的缓存淘汰算法"></a><strong>常见的缓存淘汰算法</strong></h2><ul><li>FIFO（First In First Out，先进先出），根据缓存被存储的时间，离当前最远的数据优先被淘汰；</li><li>LRU（LeastRecentlyUsed，最近最少使用），根据最近被使用的时间，离当前最远的数据优先被淘汰；</li><li>LFU（LeastFrequentlyUsed，最不经常使用），在一段时间内，缓存数据被使用次数最少的会被淘汰。</li></ul><h2 id="布隆过滤器原理，优缺点"><a href="#布隆过滤器原理，优缺点" class="headerlink" title="布隆过滤器原理，优缺点"></a><strong>布隆过滤器原理，优缺点</strong></h2><ul><li>位图：int[10]，每个int类型的整数是4*8&#x3D;32个bit，则int[10]一共有320 bit，每个bit非0即1，初始化时都是0</li><li>添加数据时：将数据进行hash得到hash值，对应到bit位，将该bit改为1，hash函数可以定义多个，则 一个数据添加会将多个（hash函数个数）bit改为1，多个hash函数的目的是减少hash碰撞的概率</li><li>查询数据：hash函数计算得到hash值，对应到bit中，如果有一个为0，则说明数据不在bit中，如果都为1，则该数据可能在bit中</li></ul><p>优点：</p><ul><li>占用内存小</li><li>增加和查询元素的时间复杂度为：O(K), (K为哈希函数的个数，一般比较小)，与数据量大小无关哈希函数相互之间没有关系，方便硬件并行运算</li><li>布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势 数据量很大时，布隆过滤器可以表示全集</li><li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</li></ul><p>缺点：</p><ul><li>误判率，即存在假阳性(False Position)，不能准确判断元素是否在集合中不能获取元素本身</li><li>一般情况下不能从布隆过滤器中删除元素</li></ul><h2 id="分布式缓存寻址算法"><a href="#分布式缓存寻址算法" class="headerlink" title="分布式缓存寻址算法"></a><strong>分布式缓存寻址算法</strong></h2><ul><li>hash算法：根据key进行hash函数运算、结果对分片数取模，确定分片 适合固定分片数的场景，扩展分片或者减少分片时，所有数据都需要重新计算分片、存储</li><li>一致性hash：将整个hash值得区间组织成一个闭合的圆环，计算每台服务器的hash值、映射到圆环中。使用相同的hash算法计算数据的hash值，映射到圆环，顺时针寻找，找到的第一个服务器就是数据存储的服务器。新增及减少节点时只会影响节点到他逆时针最近的一个服务器之间的值 存在hash环倾斜的问题，即服务器分布不均匀，可以通过虚拟节点解决</li><li>hash slot：将数据与服务器隔离开，数据与slot映射，slot与服务器映射，数据进行hash决定存放的slot，新增及删除节点时，将slot进行迁移即可</li></ul><h2 id="Spring-Cloud和Dubbo有哪些区别？"><a href="#Spring-Cloud和Dubbo有哪些区别？" class="headerlink" title="Spring Cloud和Dubbo有哪些区别？"></a><strong>Spring Cloud和Dubbo有哪些区别？</strong></h2><p>Spring Cloud是一个微服务框架，提供了微服务领域中的很多功能组件，Dubbo一开始是一个RPC调用框架，核心是解决服务调用间的问题，Spring Cloud是一个大而全的框架，Dubbo则更侧重于服务调用，所以Dubbo所提供的功能没有Spring Cloud全面，但是Dubbo的服务调用性能比Spring Cloud高，不过Spring Cloud和Dubbo并不是对立的，是可以结合起来一起使用的。</p><h2 id="什么是服务雪崩？什么是服务限流？"><a href="#什么是服务雪崩？什么是服务限流？" class="headerlink" title="什么是服务雪崩？什么是服务限流？"></a><strong>什么是服务雪崩？什么是服务限流？</strong></h2><ol><li>当服务A调用服务B，服务B调用C，此时大量请求突然请求服务A，假如服务A本身能抗住这些请求，但是如果服务C抗不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断。</li><li>服务限流是指在高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的。</li></ol><h2 id="什么是服务熔断？什么是服务降级？区别是什么？"><a href="#什么是服务熔断？什么是服务降级？区别是什么？" class="headerlink" title="什么是服务熔断？什么是服务降级？区别是什么？"></a><strong>什么是服务熔断？什么是服务降级？区别是什么？</strong></h2><ol><li>服务熔断是指，当服务A调用的某个服务B不可用时，上游服务A为了保证自己不受影响，从而不再调用服务B，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复。</li><li>服务降级是指，当发现系统压力过载时，可以通过关闭某个服务，或限流某个服务来减轻系统压力，这就是服务降级。</li></ol><p>相同点：</p><ol><li>都是为了防止系统崩溃</li><li>都让用户体验到某些功能暂时不可用</li></ol><p>不同点：熔断是下游服务故障触发的，降级是为了降低系统负载</p><h2 id="SOA、分布式、微服务之间有什么关系和区别？"><a href="#SOA、分布式、微服务之间有什么关系和区别？" class="headerlink" title="SOA、分布式、微服务之间有什么关系和区别？"></a><strong>SOA、分布式、微服务之间有什么关系和区别？</strong></h2><ol><li>分布式架构是指将单体架构中的各个部分拆分，然后部署不同的机器或进程中去，SOA和微服务基本上都是分布式架构的</li><li>SOA是一种面向服务的架构，系统的所有服务都注册在总线上，当调用服务时，从总线上查找服务信息，然后调用</li><li>微服务是一种更彻底的面向服务的架构，将系统中各个功能个体抽成一个个小的应用程序，基本保持一个应用对应的一个服务的架构</li></ol><h2 id="怎么拆分微服务？"><a href="#怎么拆分微服务？" class="headerlink" title="怎么拆分微服务？"></a><strong>怎么拆分微服务？</strong></h2><p>拆分微服务的时候，为了尽量保证微服务的稳定，会有一些基本的准则：</p><ol><li>微服务之间尽量不要有业务交叉。</li><li>微服务之前只能通过接口进行服务调用，而不能绕过接口直接访问对方的数据。</li><li>高内聚，低耦合。</li></ol><h2 id="怎样设计出高内聚、低耦合的微服务？"><a href="#怎样设计出高内聚、低耦合的微服务？" class="headerlink" title="怎样设计出高内聚、低耦合的微服务？"></a><strong>怎样设计出高内聚、低耦合的微服务？</strong></h2><p>高内聚低耦合，是一种从上而下指导微服务设计的方法。实现高内聚低耦合的工具主要有 同步的接口调用 和 异步的事件驱动 两种方式。</p><h2 id="有没有了解过DDD领域驱动设计？"><a href="#有没有了解过DDD领域驱动设计？" class="headerlink" title="有没有了解过DDD领域驱动设计？"></a><strong>有没有了解过DDD领域驱动设计？</strong></h2><p>什么是DDD： 在2004年，由Eric Evans提出了， DDD是面对软件复杂之道。Domain-Driven- Design –Tackling Complexity in the Heart of Software<br>大泥团： 不利于微服务的拆分。大泥团结构拆分出来的微服务依然是泥团机构，当服务业务逐渐复杂，这个泥团又会膨胀成为大泥团。<br>DDD只是一种方法论，没有一个稳定的技术框架。DDD要求领域是跟技术无关、跟存储无关、跟通信无关。</p><h2 id="什么是中台？"><a href="#什么是中台？" class="headerlink" title="什么是中台？"></a><strong>什么是中台？</strong></h2><p>所谓中台，就是将各个业务线中可以复用的一些功能抽取出来，剥离个性，提取共性，形成一些可复用的组件。<br>大体上，中台可以分为三类 业务中台、数据中台和技术中台。大数据杀熟-数据中台<br>中台跟DDD结合： DDD会通过限界上下文将系统拆分成一个一个的领域， 而这种限界上下文，天生就成了中台之间的逻辑屏障。<br>DDD在技术与资源调度方面都能够给中台建设提供不错的指导。<br>DDD分为战略设计和战术设计。 上层的战略设计能够很好的指导中台划分，下层的战术设计能够很好的指导微服务搭建。</p><h2 id="你的项目中是怎么保证微服务敏捷开发的？"><a href="#你的项目中是怎么保证微服务敏捷开发的？" class="headerlink" title="你的项目中是怎么保证微服务敏捷开发的？"></a><strong>你的项目中是怎么保证微服务敏捷开发的？</strong></h2><ul><li>开发运维一体化。</li><li>敏捷开发： 目的就是为了提高团队的交付效率，快速迭代，快速试错</li><li>每个月固定发布新版本，以分支的形式保存到代码仓库中。快速入职。任务面板、站立会议。团队人员灵活流动，同时形成各个专家代表</li><li>测试环境- 生产环境 -开发测试环境SIT-集成测试环境-压测环境STR-预投产环境-生产环境PRD</li><li>晨会、周会、需求拆分会</li></ul><h2 id="如何进行消息队列选型？"><a href="#如何进行消息队列选型？" class="headerlink" title="如何进行消息队列选型？"></a><strong>如何进行消息队列选型？</strong></h2><ul><li>Kafka：<ul><li>优点： 吞吐量非常大，性能非常好，集群高可用。</li><li>缺点：会丢数据，功能比较单一。</li><li>使用场景：日志分析、大数据采集</li></ul></li><li>RabbitMQ：<ul><li>优点： 消息可靠性高，功能全面。</li><li>缺点：吞吐量比较低，消息积累会严重影响性能。erlang语言不好定制。</li><li>使用场景：小规模场景。</li></ul></li><li>RocketMQ：<ul><li>优点：高吞吐、高性能、高可用，功能非常全面。</li><li>缺点：开源版功能不如云上商业版。官方文档和周边生态还不够成熟。客户端只支持java。</li><li>使用场景：几乎是全场景。</li></ul></li></ul><h2 id="RocketMQ的事务消息是如何实现的"><a href="#RocketMQ的事务消息是如何实现的" class="headerlink" title="RocketMQ的事务消息是如何实现的"></a><strong>RocketMQ的事务消息是如何实现的</strong></h2><p>![](面试题全集&#x2F;image (2).png)</p><ol><li>生产者订单系统先发送一条half消息到Broker，half消息对消费者而言是不可见的</li><li>再创建订单，根据创建订单成功与否，向Broker发送commit或rollback</li><li>并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功</li><li>一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束</li><li>如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理</li></ol><h2 id="为什么RocketMQ不使用Zookeeper作为注册中心呢？"><a href="#为什么RocketMQ不使用Zookeeper作为注册中心呢？" class="headerlink" title="为什么RocketMQ不使用Zookeeper作为注册中心呢？"></a><strong>为什么RocketMQ不使用Zookeeper作为注册中心呢？</strong></h2><p>根据CAP理论，同时最多只能满足两个点，而zookeeper满足的是CP，也就是说zookeeper并不能保证服务的可用性，zookeeper在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。<br>基于性能的考虑，NameServer本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而zookeeper的写是不可扩展的，而zookeeper要解决这个问题只能通过划分领域，划分多个zookeeper集群来解决，首先操作起来太复杂，其次这样还是又违反了CAP中的A的设计，导致服务之间是不连通的。<br>持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper 节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。<br>消息发送应该弱依赖注册中心，而RocketMQ的设计理念也正是基于此，生产者在第一次发送消息的时候从NameServer获取到Broker地址后缓存到本地，如果NameServer整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。</p><h2 id="RocketMQ的实现原理"><a href="#RocketMQ的实现原理" class="headerlink" title="RocketMQ的实现原理"></a><strong>RocketMQ的实现原理</strong></h2><p>RocketMQ由NameServer注册中心集群、Producer生产者集群、Consumer消费者集群和若干Broker（RocketMQ进程）组成，它的架构原理是这样的：<br>Broker在启动的时候去向所有的NameServer注册，并保持长连接，每30s发送一次心跳<br>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息<br>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</p><h2 id="RocketMQ为什么速度快"><a href="#RocketMQ为什么速度快" class="headerlink" title="RocketMQ为什么速度快"></a><strong>RocketMQ为什么速度快</strong></h2><p>因为使用了顺序存储、Page Cache和异步刷盘。我们在写入commitlog的时候是顺序写入的，这样比随机写入的性能就会提高很多，写入commitlog的时候并不是直接写入磁盘，而是先写入操作系统的PageCache，最后由操作系统异步将缓存中的数据刷到磁盘</p><h2 id="消息队列如何保证消息可靠传输"><a href="#消息队列如何保证消息可靠传输" class="headerlink" title="消息队列如何保证消息可靠传输"></a><strong>消息队列如何保证消息可靠传输</strong></h2><p>消息可靠传输代表了两层意思，既不能多也不能少。</p><ol><li>为了保证消息不多，也就是消息不能重复，也就是生产者不能重复生产消息，或者消费者不能重复消费消息</li><li>首先要确保消息不多发，这个不常出现，也比较难控制，因为如果出现了多发，很大的原因是生产者自己的原因，如果要避免出现问题，就需要在消费端做控制</li><li>要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决生产者重复发送消息的问题</li><li>消息不能少，意思就是消息不能丢失，生产者发送的消息，消费者一定要能消费到，对于这个问题，就要考虑两个方面</li><li>生产者发送消息时，要确认broker确实收到并持久化了这条消息，比如RabbitMQ的confirm机制，Kafka的ack机制都可以保证生产者能正确的将消息发送给broker</li><li>broker要等待消费者真正确认消费到了消息时才删除掉消息，这里通常就是消费端ack机制，消费者接收到一条消息后，如果确认没问题了，就可以给broker发送一个ack，broker接收到ack后才会删除消息</li></ol><h2 id="消息队列有哪些作用"><a href="#消息队列有哪些作用" class="headerlink" title="消息队列有哪些作用"></a><strong>消息队列有哪些作用</strong></h2><ol><li>解耦：使用消息队列来作为两个系统之间的通讯方式，两个系统不需要相互依赖了</li><li>异步：系统A给消息队列发送完消息之后，就可以继续做其他事情了</li><li>流量削峰：如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，由消费者自己控制消费速度</li></ol><h2 id="死信队列是什么？延时队列是什么？"><a href="#死信队列是什么？延时队列是什么？" class="headerlink" title="死信队列是什么？延时队列是什么？"></a><strong>死信队列是什么？延时队列是什么？</strong></h2><ol><li>死信队列也是一个消息队列，它是用来存放那些没有成功消费的消息的，通常可以用来作为消息重试</li><li>延时队列就是用来存放需要在指定时间被处理的元素的队列，通常可以用来处理一些具有过期性操作的业务，比如十分钟内未支付则取消订单</li></ol><h2 id="如何保证消息的高效读写？"><a href="#如何保证消息的高效读写？" class="headerlink" title="如何保证消息的高效读写？"></a><strong>如何保证消息的高效读写？</strong></h2><p>零拷贝： kafka和RocketMQ都是通过零拷贝技术来优化文件读写。<br>传统文件复制方式： 需要对文件在内存中进行四次拷贝。<br>零拷贝： 有两种方式， mmap和transfile，Java当中对零拷贝进行了封装， Mmap方式通过MappedByteBuffer对象进行操作，而transfile通过FileChannel来进行操作。Mmap 适合比较小的文件，通常文件大小不要超过1.5G ~2G 之间。Transfile没有文件大小限制。RocketMQ当中使用Mmap方式来对他的文件进行读写。<br>在kafka当中，他的index日志文件也是通过mmap的方式来读写的。在其他日志文件当中，并没有使用零拷贝的方式。Kafka使用transfile方式将硬盘数据加载到网卡。</p><h2 id="epoll和poll的区别"><a href="#epoll和poll的区别" class="headerlink" title="epoll和poll的区别"></a><strong>epoll和poll的区别</strong></h2><ol><li>select模型，使用的是数组来存储Socket连接文件描述符，容量是固定的，需要通过轮询来判断是否发生了IO事件</li><li>poll模型，使用的是链表来存储Socket连接文件描述符，容量是不固定的，同样需要通过轮询来判断是否发生了IO事件</li><li>epoll模型，epoll和poll是完全不同的，epoll是一种事件通知模型，当发生了IO事件时，应用程序才进行IO操作，不需要像poll模型那样主动去轮询</li></ol><h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a><strong>TCP的三次握手和四次挥手</strong></h2><p>TCP协议是7层网络协议中的传输层协议，负责数据的可靠传输。<br>在建立TCP连接时，需要通过三次握手来建立，过程是：</p><ol><li>客户端向服务端发送一个SYN</li><li>服务端接收到SYN后，给客户端发送一个SYN_ACK</li><li>客户端接收到SYN_ACK后，再给服务端发送一个ACK</li></ol><p>在断开TCP连接时，需要通过四次挥手来断开，过程是：</p><ol><li>客户端向服务端发送FIN</li><li>服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还有数据正在处理</li><li>服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接</li><li>客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了</li></ol><h2 id="浏览器发出一个请求到收到响应经历了哪些步骤？"><a href="#浏览器发出一个请求到收到响应经历了哪些步骤？" class="headerlink" title="浏览器发出一个请求到收到响应经历了哪些步骤？"></a><strong>浏览器发出一个请求到收到响应经历了哪些步骤？</strong></h2><ol><li>浏览器解析用户输入的URL，生成一个HTTP格式的请求</li><li>先根据URL域名从本地hosts文件查找是否有映射IP，如果没有就将域名发送给电脑所配置的DNS进行域名解析，得到IP地址</li><li>浏览器通过操作系统将请求通过四层网络协议发送出去</li><li>途中可能会经过各种路由器、交换机，最终到达服务器</li><li>服务器收到请求后，根据请求所指定的端口，将请求传递给绑定了该端口的应用程序，比如8080被tomcat占用了</li><li>tomcat接收到请求数据后，按照http协议的格式进行解析，解析得到所要访问的servlet</li><li>然后servlet来处理这个请求，如果是SpringMVC中的DispatcherServlet，那么则会找到对应的Controller中的方法，并执行该方法得到结果</li><li>Tomcat得到响应结果后封装成HTTP响应的格式，并再次通过网络发送给浏览器所在的服务器</li><li>浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并渲染</li></ol><h2 id="跨域请求是什么？有什么问题？怎么解决？"><a href="#跨域请求是什么？有什么问题？怎么解决？" class="headerlink" title="跨域请求是什么？有什么问题？怎么解决？"></a><strong>跨域请求是什么？有什么问题？怎么解决？</strong></h2><p>跨域是指浏览器在发起网络请求时，会检查该请求所对应的协议、域名、端口和当前网页是否一致，如果不一致则浏览器会进行限制，比如在<a href="http://www.baidu.com的某个网页中，如果使用ajax去访问www.jd.com是不行的，但是如果是img、iframe、script等标签的src属性去访问则是可以的，之所以浏览器要做这层限制，是为了用户信息安全。但是如果开发者想要绕过这层限制也是可以的：">www.baidu.com的某个网页中，如果使用ajax去访问www.jd.com是不行的，但是如果是img、iframe、script等标签的src属性去访问则是可以的，之所以浏览器要做这层限制，是为了用户信息安全。但是如果开发者想要绕过这层限制也是可以的：</a></p><ol><li>response添加header，比如resp.setHeader(“Access-Control-Allow-Origin”, “*”);表示可以访问所有网站，不受是否同源的限制</li><li>jsonp的方式，该技术底层就是基于script标签来实现的，因为script标签是可以跨域的</li><li>后台自己控制，先访问同域名下的接口，然后在接口中再去使用HTTPClient等工具去调用目标接口</li><li>网关，和第三种方式类似，都是交给后台服务来进行跨域访问</li></ol><h2 id="零拷贝是什么"><a href="#零拷贝是什么" class="headerlink" title="零拷贝是什么"></a><strong>零拷贝是什么</strong></h2><p>零拷贝指的是，应用程序在需要把内核中的一块区域数据转移到另外一块内核区域去时，不需要经过先复制到用户空间，再转移到目标内核区域去了，而直接实现转移。</p><p><img src="/2023-02-26-5496f818735c/figure1.gif"></p><p><img src="/2023-02-26-5496f818735c/%5C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%85%A8%E9%9B%86%5Cfigure3.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JDK、JRE、JVM之间的区别&quot;&gt;&lt;a href=&quot;#JDK、JRE、JVM之间的区别&quot; class=&quot;headerlink&quot; title=&quot;JDK、JRE、JVM之间的区别&quot;&gt;&lt;/a&gt;&lt;strong&gt;JDK、JRE、JVM之间的区别&lt;/strong&gt;&lt;/h2&gt;</summary>
      
    
    
    
    <category term="面试题" scheme="https://zhuxuchen.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://zhuxuchen.github.io/tags/Java/"/>
    
    <category term="面试题" scheme="https://zhuxuchen.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java框架篇</title>
    <link href="https://zhuxuchen.github.io/2023-02-26-cbddd37fc414/"/>
    <id>https://zhuxuchen.github.io/2023-02-26-cbddd37fc414/</id>
    <published>2023-02-26T07:26:17.000Z</published>
    <updated>2023-02-26T07:29:14.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><h2 id="1-Spring-refresh-流程"><a href="#1-Spring-refresh-流程" class="headerlink" title="1. Spring refresh 流程"></a>1. Spring refresh 流程</h2><p><strong>要求</strong></p><ul><li>掌握 refresh 的 12 个步骤</li></ul><p><strong>Spring refresh 概述</strong></p><p>refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤：</p><ol><li><p>prepareRefresh</p></li><li><p>obtainFreshBeanFactory</p></li><li><p>prepareBeanFactory</p></li><li><p>postProcessBeanFactory</p></li><li><p>invokeBeanFactoryPostProcessors</p></li><li><p>registerBeanPostProcessors</p></li><li><p>initMessageSource</p></li><li><p>initApplicationEventMulticaster</p></li><li><p>onRefresh</p></li><li><p>registerListeners</p></li><li><p>finishBeanFactoryInitialization</p></li><li><p>finishRefresh</p></li></ol><blockquote><p><em><strong>功能分类</strong></em></p><ul><li><p>1 为准备环境</p></li><li><p>2 3 4 5 6 为准备 BeanFactory</p></li><li><p>7 8 9 10 12 为准备 ApplicationContext</p></li><li><p>11 为初始化 BeanFactory 中非延迟单例 bean</p></li></ul></blockquote><p><strong>1. prepareRefresh</strong></p><ul><li><p>这一步创建和准备了 Environment 对象，它作为 ApplicationContext 的一个成员变量</p></li><li><p>Environment 对象的作用之一是为后续 @Value，值注入时提供键值</p></li><li><p>Environment 分成三个主要部分</p><ul><li>systemProperties - 保存 java 环境键值</li><li>systemEnvironment - 保存系统环境键值</li><li>自定义 PropertySource - 保存自定义键值，例如来自于 *.properties 文件的键值</li></ul></li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210902181639048.png" alt="image-20210902181639048"></p><p><strong>2. obtainFreshBeanFactory</strong></p><ul><li>这一步获取（或创建） BeanFactory，它也是作为 ApplicationContext 的一个成员变量</li><li>BeanFactory 的作用是负责 bean 的创建、依赖注入和初始化，bean 的各项特征由 BeanDefinition 定义<ul><li>BeanDefinition 作为 bean 的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等</li><li>BeanDefinition 的来源有多种多样，可以是通过 xml 获得、配置类获得、组件扫描获得，也可以是编程添加</li></ul></li><li>所有的 BeanDefinition 会存入 BeanFactory 中的 beanDefinitionMap 集合</li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210902182004819.png" alt="image-20210902182004819"></p><p><strong>3. prepareBeanFactory</strong></p><ul><li>这一步会进一步完善 BeanFactory，为它的各项成员变量赋值</li><li>beanExpressionResolver 用来解析 SpEL，常见实现为 StandardBeanExpressionResolver</li><li>propertyEditorRegistrars 会注册类型转换器<ul><li>它在这里使用了 ResourceEditorRegistrar 实现类</li><li>并应用 ApplicationContext 提供的 Environment 完成 ${ } 解析</li></ul></li><li>registerResolvableDependency 来注册 beanFactory 以及 ApplicationContext，让它们也能用于依赖注入</li><li>beanPostProcessors 是 bean 后处理器集合，会工作在 bean 的生命周期各个阶段，此处会添加两个：<ul><li>ApplicationContextAwareProcessor 用来解析 Aware 接口</li><li>ApplicationListenerDetector 用来识别容器中 ApplicationListener 类型的 bean</li></ul></li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210902182541925.png" alt="image-20210902182541925"></p><p><strong>4. postProcessBeanFactory</strong></p><ul><li>这一步是空实现，留给子类扩展。<ul><li>一般 Web 环境的 ApplicationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory</li></ul></li><li>这里体现的是模板方法设计模式</li></ul><p><strong>5. invokeBeanFactoryPostProcessors</strong></p><ul><li>这一步会调用 beanFactory 后处理器</li><li>beanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition</li><li>常见的 beanFactory 后处理器有<ul><li>ConfigurationClassPostProcessor – 解析 @Configuration、@Bean、@Import、@PropertySource 等</li><li>PropertySourcesPlaceHolderConfigurer – 替换 BeanDefinition 中的 ${ }</li><li>MapperScannerConfigurer – 补充 Mapper 接口对应的 BeanDefinition</li></ul></li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210902183232114.png" alt="image-20210902183232114"></p><p><strong>6. registerBeanPostProcessors</strong></p><ul><li>这一步是继续从 beanFactory 中找出 bean 后处理器，添加至 beanPostProcessors 集合中</li><li>bean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段，常见的有：<ul><li>AutowiredAnnotationBeanPostProcessor 功能有：解析 @Autowired，@Value 注解</li><li>CommonAnnotationBeanPostProcessor 功能有：解析 @Resource，@PostConstruct，@PreDestroy</li><li>AnnotationAwareAspectJAutoProxyCreator 功能有：为符合切点的目标 bean 自动创建代理</li></ul></li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210902183520307.png" alt="image-20210902183520307"></p><p><strong>7. initMessageSource</strong></p><ul><li>这一步是为 ApplicationContext 添加 messageSource 成员，实现国际化功能</li><li>去 beanFactory 内找名为 messageSource 的 bean，如果没有，则提供空的 MessageSource 实现</li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210902183819984.png" alt="image-20210902183819984"></p><p><strong>8. initApplicationContextEventMulticaster</strong></p><ul><li>这一步为 ApplicationContext 添加事件广播器成员，即 applicationContextEventMulticaster</li><li>它的作用是发布事件给监听器</li><li>去 beanFactory 找名为 applicationEventMulticaster 的 bean 作为事件广播器，若没有，会创建默认的事件广播器</li><li>之后就可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件</li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210902183943469.png" alt="image-20210902183943469"></p><p><strong>9. onRefresh</strong></p><ul><li>这一步是空实现，留给子类扩展<ul><li>SpringBoot 中的子类在这里准备了 WebServer，即内嵌 web 容器</li></ul></li><li>体现的是模板方法设计模式</li></ul><p><strong>10. registerListeners</strong></p><ul><li>这一步会从多种途径找到事件监听器，并添加至 applicationEventMulticaster</li><li>事件监听器顾名思义，用来接收事件广播器发布的事件，有如下来源<ul><li>事先编程添加的</li><li>来自容器中的 bean</li><li>来自于 @EventListener 的解析</li></ul></li><li>要实现事件监听器，只需要实现 ApplicationListener 接口，重写其中 onApplicationEvent(E e) 方法即可</li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210902184343872.png" alt="image-20210902184343872"></p><p><strong>11. finishBeanFactoryInitialization</strong></p><ul><li>这一步会将 beanFactory 的成员补充完毕，并初始化所有非延迟单例 bean</li><li>conversionService 也是一套转换机制，作为对 PropertyEditor 的补充</li><li>embeddedValueResolvers 即内嵌值解析器，用来解析 @Value 中的 ${ }，借用的是 Environment 的功能</li><li>singletonObjects 即单例池，缓存所有单例对象<ul><li>对象的创建都分三个阶段，每一阶段都有不同的 bean 后处理器参与进来，扩展功能</li></ul></li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210902184641623.png" alt="image-20210902184641623"></p><p><strong>12. finishRefresh</strong></p><ul><li>这一步会为 ApplicationContext 添加 lifecycleProcessor 成员，用来控制容器内需要生命周期管理的 bean</li><li>如果容器中有名称为 lifecycleProcessor 的 bean 就用它，否则创建默认的生命周期管理器</li><li>准备好生命周期管理器，就可以实现<ul><li>调用 context 的 start，即可触发所有实现 LifeCycle 接口 bean 的 start</li><li>调用 context 的 stop，即可触发所有实现 LifeCycle 接口 bean 的 stop</li></ul></li><li>发布 ContextRefreshed 事件，整个 refresh 执行完成</li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210902185052433.png" alt="image-20210902185052433"></p><h2 id="2-Spring-bean-生命周期"><a href="#2-Spring-bean-生命周期" class="headerlink" title="2. Spring bean 生命周期"></a>2. Spring bean 生命周期</h2><p><strong>要求</strong></p><ul><li>掌握 Spring bean 的生命周期</li></ul><p><strong>bean 生命周期 概述</strong></p><p>bean 的生命周期从调用 beanFactory 的 getBean 开始，到这个 bean 被销毁，可以总结为以下七个阶段：</p><ol><li>处理名称，检查缓存</li><li>处理父子容器</li><li>处理 dependsOn</li><li>选择 scope 策略</li><li>创建 bean</li><li>类型转换处理</li><li>销毁 bean</li></ol><blockquote><p><em><strong>注意</strong></em></p><ul><li>划分的阶段和名称并不重要，重要的是理解整个过程中做了哪些事情</li></ul></blockquote><p><strong>1. 处理名称，检查缓存</strong></p><ul><li>这一步会处理别名，将别名解析为实际名称</li><li>对 FactoryBean 也会特殊处理，如果以 &amp; 开头表示要获取 FactoryBean 本身，否则表示要获取其产品</li><li>这里针对单例对象会检查一级、二级、三级缓存<ul><li>singletonFactories 三级缓存，存放单例工厂对象</li><li>earlySingletonObjects 二级缓存，存放单例工厂的产品对象<ul><li>如果发生循环依赖，产品是代理；无循环依赖，产品是原始对象</li></ul></li><li>singletonObjects 一级缓存，存放单例成品对象</li></ul></li></ul><p><strong>2. 处理父子容器</strong></p><ul><li>如果当前容器根据名字找不到这个 bean，此时若父容器存在，则执行父容器的 getBean 流程</li><li>父子容器的 bean 名称可以重复</li></ul><p><strong>3. 处理 dependsOn</strong></p><ul><li>如果当前 bean 有通过 dependsOn 指定了非显式依赖的 bean，这一步会提前创建这些 dependsOn 的 bean </li><li>所谓非显式依赖，就是指两个 bean 之间不存在直接依赖关系，但需要控制它们的创建先后顺序</li></ul><p><strong>4. 选择 scope 策略</strong></p><ul><li>对于 singleton scope，首先到单例池去获取 bean，如果有则直接返回，没有再进入创建流程</li><li>对于 prototype scope，每次都会进入创建流程</li><li>对于自定义 scope，例如 request，首先到 request 域获取 bean，如果有则直接返回，没有再进入创建流程</li></ul><p><strong>5.1 创建 bean - 创建 bean 实例</strong></p><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td>有自定义 TargetSource 的情况</td><td>由 AnnotationAwareAspectJAutoProxyCreator 创建代理返回</td></tr><tr><td>Supplier 方式创建 bean 实例</td><td>为 Spring 5.0 新增功能，方便编程方式创建  bean  实例</td></tr><tr><td>FactoryMethod 方式  创建 bean  实例</td><td>① 分成静态工厂与实例工厂；② 工厂方法若有参数，需要对工厂方法参数进行解析，利用  resolveDependency；③ 如果有多个工厂方法候选者，还要进一步按权重筛选</td></tr><tr><td>AutowiredAnnotationBeanPostProcessor</td><td>① 优先选择带  @Autowired  注解的构造；② 若有唯一的带参构造，也会入选</td></tr><tr><td>mbd.getPreferredConstructors</td><td>选择所有公共构造，这些构造之间按权重筛选</td></tr><tr><td>采用默认构造</td><td>如果上面的后处理器和 BeanDefiniation 都没找到构造，采用默认构造，即使是私有的</td></tr></tbody></table><p><strong>5.2 创建 bean - 依赖注入</strong></p><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td>AutowiredAnnotationBeanPostProcessor</td><td>识别   @Autowired  及 @Value  标注的成员，封装为  InjectionMetadata 进行依赖注入</td></tr><tr><td>CommonAnnotationBeanPostProcessor</td><td>识别   @Resource  标注的成员，封装为  InjectionMetadata 进行依赖注入</td></tr><tr><td>resolveDependency</td><td>用来查找要装配的值，可以识别：① Optional；② ObjectFactory 及 ObjectProvider；③ @Lazy  注解；④ @Value  注解（${  }, #{ }, 类型转换）；⑤ 集合类型（Collection，Map，数组等）；⑥ 泛型和  @Qualifier（用来区分类型歧义）；⑦ primary  及名字匹配（用来区分类型歧义）</td></tr><tr><td>AUTOWIRE_BY_NAME</td><td>根据成员名字找 bean 对象，修改 mbd 的 propertyValues，不会考虑简单类型的成员</td></tr><tr><td>AUTOWIRE_BY_TYPE</td><td>根据成员类型执行 resolveDependency 找到依赖注入的值，修改  mbd 的 propertyValues</td></tr><tr><td>applyPropertyValues</td><td>根据 mbd 的 propertyValues 进行依赖注入（即xml中 &#96;&lt;property name ref</td></tr></tbody></table><p><strong>5.3 创建 bean - 初始化</strong></p><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td>内置 Aware 接口的装配</td><td>包括 BeanNameAware，BeanFactoryAware 等</td></tr><tr><td>扩展 Aware 接口的装配</td><td>由 ApplicationContextAwareProcessor 解析，执行时机在  postProcessBeforeInitialization</td></tr><tr><td>@PostConstruct</td><td>由 CommonAnnotationBeanPostProcessor 解析，执行时机在  postProcessBeforeInitialization</td></tr><tr><td>InitializingBean</td><td>通过接口回调执行初始化</td></tr><tr><td>initMethod</td><td>根据 BeanDefinition 得到的初始化方法执行初始化，即 <code>&lt;bean init-method&gt;</code> 或 @Bean(initMethod)</td></tr><tr><td>创建 aop 代理</td><td>由 AnnotationAwareAspectJAutoProxyCreator 创建，执行时机在  postProcessAfterInitialization</td></tr></tbody></table><p><strong>5.4 创建 bean - 注册可销毁 bean</strong></p><p>在这一步判断并登记可销毁 bean</p><ul><li>判断依据<ul><li>如果实现了 DisposableBean 或 AutoCloseable 接口，则为可销毁 bean</li><li>如果自定义了 destroyMethod，则为可销毁 bean</li><li>如果采用 @Bean 没有指定 destroyMethod，则采用自动推断方式获取销毁方法名（close，shutdown）</li><li>如果有 @PreDestroy 标注的方法</li></ul></li><li>存储位置<ul><li>singleton scope 的可销毁 bean 会存储于 beanFactory 的成员当中</li><li>自定义 scope 的可销毁 bean 会存储于对应的域对象当中</li><li>prototype scope 不会存储，需要自己找到此对象销毁</li></ul></li><li>存储时都会封装为 DisposableBeanAdapter 类型对销毁方法的调用进行适配</li></ul><p><strong>6. 类型转换处理</strong></p><ul><li>如果 getBean 的 requiredType 参数与实际得到的对象类型不同，会尝试进行类型转换</li></ul><p><strong>7. 销毁 bean</strong></p><ul><li>销毁时机<ul><li>singleton bean 的销毁在 ApplicationContext.close 时，此时会找到所有 DisposableBean 的名字，逐一销毁</li><li>自定义 scope bean 的销毁在作用域对象生命周期结束时</li><li>prototype bean 的销毁可以通过自己手动调用 AutowireCapableBeanFactory.destroyBean 方法执行销毁</li></ul></li><li>同一 bean 中不同形式销毁方法的调用次序<ul><li>优先后处理器销毁，即 @PreDestroy</li><li>其次 DisposableBean 接口销毁</li><li>最后 destroyMethod 销毁（包括自定义名称，推断名称，AutoCloseable 接口 多选一）</li></ul></li></ul><h2 id="3-Spring-bean-循环依赖"><a href="#3-Spring-bean-循环依赖" class="headerlink" title="3. Spring bean 循环依赖"></a>3. Spring bean 循环依赖</h2><p><strong>要求</strong></p><ul><li>掌握单例 set 方式循环依赖的原理</li><li>掌握其它循环依赖的解决方法</li></ul><p><strong>循环依赖的产生</strong></p><ul><li>首先要明白，bean 的创建要遵循一定的步骤，必须是创建、注入、初始化三步，这些顺序不能乱</li></ul><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903085238916.png" alt="image-20210903085238916" style="zoom:50%;"><ul><li><p>set 方法（包括成员变量）的循环依赖如图所示</p><ul><li><p>可以在【a 创建】和【a set 注入 b】之间加入 b 的整个流程来解决</p></li><li><p>【b set 注入 a】 时可以成功，因为之前 a 的实例已经创建完毕</p></li><li><p>a 的顺序，及 b 的顺序都能得到保障</p></li></ul></li></ul><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903085454603.png" alt="image-20210903085454603" style="zoom: 33%;"><ul><li>构造方法的循环依赖如图所示，显然无法用前面的方法解决</li></ul><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903085906315.png" alt="image-20210903085906315" style="zoom: 50%;"><p><strong>构造循环依赖的解决</strong></p><ul><li>思路1<ul><li>a 注入 b 的代理对象，这样能够保证 a 的流程走通</li><li>后续需要用到 b 的真实对象时，可以通过代理间接访问</li></ul></li></ul><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903091627659.png" alt="image-20210903091627659" style="zoom: 50%;"><ul><li>思路2<ul><li>a 注入 b 的工厂对象，让 b 的实例创建被推迟，这样能够保证 a 的流程先走通</li><li>后续需要用到 b 的真实对象时，再通过 ObjectFactory 工厂间接访问</li></ul></li></ul><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903091743366.png" alt="image-20210903091743366" style="zoom:50%;"><ul><li>示例1：用 @Lazy 为构造方法参数生成代理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="meta">@Lazy</span> B b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(B b) &#123;&#125;&quot;</span>, b.getClass());</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例2：用 ObjectProvider 延迟依赖对象的创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> ObjectProvider&lt;B&gt; b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(ObjectProvider&lt;B&gt; b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(&#123;&#125;)&quot;</span>, b);</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(A.class).b.getObject());</span><br><span class="line">        System.out.println(context.getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例3：用 @Scope 产生代理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(context.getDefaultListableBeanFactory());</span><br><span class="line">        scanner.scan(<span class="string">&quot;com.itheima.app60.sub&quot;</span>);</span><br><span class="line">        context.refresh();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;A(B b) &#123;&#125;&quot;</span>, b.getClass());</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例4：用 Provider 接口解决，原理上与 ObjectProvider 一样，Provider 接口是独立的 jar 包，需要加入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> Provider&lt;B&gt; b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(Provider&lt;B&gt; b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(&#123;&#125;&#125;)&quot;</span>, b);</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(A.class).b.get());</span><br><span class="line">        System.out.println(context.getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决-set-循环依赖的原理"><a href="#解决-set-循环依赖的原理" class="headerlink" title="解决 set 循环依赖的原理"></a>解决 set 循环依赖的原理</h3><p><strong>一级缓存</strong></p><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903100752165.png" alt="image-20210903100752165" style="zoom:80%;"><p>作用是保证单例对象仅被创建一次</p><ul><li>第一次走 <code>getBean(&quot;a&quot;)</code> 流程后，最后会将成品 a 放入 singletonObjects 一级缓存</li><li>后续再走 <code>getBean(&quot;a&quot;)</code> 流程时，先从一级缓存中找，这时已经有成品 a，就无需再次创建</li></ul><p><strong>一级缓存与循环依赖</strong></p><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903100914140.png" alt="image-20210903100914140" style="zoom:80%;"><p>一级缓存无法解决循环依赖问题，分析如下</p><ul><li>无论是获取 bean a 还是获取 bean b，走的方法都是同一个 getBean 方法，假设先走 <code>getBean(&quot;a&quot;)</code></li><li>当 a 的实例对象创建，接下来执行 <code>a.setB()</code> 时，需要走 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 1</li><li>当 b 的实例对象创建，接下来执行 <code>b.setA()</code> 时，又回到了 <code>getBean(&quot;a&quot;)</code> 的流程，红色箭头 2</li><li>但此时 singletonObjects 一级缓存内没有成品的 a，陷入了死循环</li></ul><p><strong>二级缓存</strong></p><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903101849924.png" alt="image-20210903101849924" style="zoom:80%;"><p>解决思路如下：</p><ul><li>再增加一个 singletonFactories 缓存</li><li>在依赖注入前，即 <code>a.setB()</code> 以及 <code>b.setA()</code> 将 a 及 b 的半成品对象（未完成依赖注入和初始化）放入此缓存</li><li>执行依赖注入时，先看看 singletonFactories 缓存中是否有半成品的对象，如果有拿来注入，顺利走完流程</li></ul><p>对于上面的图</p><ul><li><code>a = new A()</code> 执行之后就会把这个半成品的 a 放入 singletonFactories 缓存，即 <code>factories.put(a)</code></li><li>接下来执行 <code>a.setB()</code>，走入 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 3</li><li>这回再执行到 <code>b.setA()</code> 时，需要一个 a 对象，有没有呢？有！</li><li><code>factories.get()</code> 在 singletonFactories  缓存中就可以找到，红色箭头 4 和 5</li><li>b 的流程能够顺利走完，将 b 成品放入 singletonObject 一级缓存，返回到 a 的依赖注入流程，红色箭头 6</li></ul><p><strong>二级缓存与创建代理</strong></p><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903103030877.png" alt="image-20210903103030877" style="zoom:80%;"><p>二级缓存无法正确处理循环依赖并且包含有代理创建的场景，分析如下</p><ul><li>spring 默认要求，在 <code>a.init</code> 完成之后才能创建代理 <code>pa = proxy(a)</code></li><li>由于 a 的代理创建时机靠后，在执行 <code>factories.put(a)</code> 向 singletonFactories 中放入的还是原始对象</li><li>接下来箭头 3、4、5 这几步 b 对象拿到和注入的都是原始对象</li></ul><p><strong>三级缓存</strong></p><p><img src="/2023-02-26-cbddd37fc414/image-20210903103628639.png" alt="image-20210903103628639"></p><p>简单分析的话，只需要将代理的创建时机放在依赖注入之前即可，但 spring 仍然希望代理的创建时机在 init 之后，只有出现循环依赖时，才会将代理的创建时机提前。所以解决思路稍显复杂：</p><ul><li>图中 <code>factories.put(fa)</code> 放入的既不是原始对象，也不是代理对象而是工厂对象 fa</li><li>当检查出发生循环依赖时，fa 的产品就是代理 pa，没有发生循环依赖，fa 的产品是原始对象 a</li><li>假设出现了循环依赖，拿到了 singletonFactories 中的工厂对象，通过在依赖注入前获得了 pa，红色箭头 5</li><li>这回 <code>b.setA()</code> 注入的就是代理对象，保证了正确性，红色箭头 7</li><li>还需要把 pa 存入新加的 earlySingletonObjects 缓存，红色箭头 6</li><li><code>a.init</code> 完成后，无需二次创建代理，从哪儿找到 pa 呢？earlySingletonObjects 已经缓存，蓝色箭头 9</li></ul><p>当成品对象产生，放入 singletonObject 后，singletonFactories 和 earlySingletonObjects 就中的对象就没有用处，清除即可</p><h2 id="4-Spring-事务失效"><a href="#4-Spring-事务失效" class="headerlink" title="4. Spring 事务失效"></a>4. Spring 事务失效</h2><p><strong>要求</strong></p><ul><li>掌握事务失效的八种场景</li></ul><p><strong>1. 抛出检查异常导致事务不能正确回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：Spring 默认只会回滚非检查异常</p></li><li><p>解法：配置 rollbackFor 属性</p><ul><li><code>@Transactional(rollbackFor = Exception.class)</code></li></ul></li></ul><p><strong>2. 业务方法内自己 try-catch 异常导致事务不能正确回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">            <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">                accountMapper.update(to, amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉</p></li><li><p>解法1：异常原样抛出</p><ul><li>在 catch 块添加 <code>throw new RuntimeException(e);</code></li></ul></li><li><p>解法2：手动设置 TransactionStatus.setRollbackOnly()</p><ul><li>在 catch 块添加 <code>TransactionInterceptor.currentTransactionStatus().setRollbackOnly();</code></li></ul></li></ul><p><strong>3. aop 切面顺序导致导致事务不能正确回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* transfer(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;log:&#123;&#125;&quot;</span>, pjp.getTarget());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：事务切面优先级最低，但如果自定义的切面优先级和他一样，则还是自定义切面在内层，这时若自定义切面没有正确抛出异常…</p></li><li><p>解法1、2：同情况2 中的解法:1、2</p></li><li><p>解法3：调整切面顺序，在 MyAspect 上添加 <code>@Order(Ordered.LOWEST_PRECEDENCE - 1)</code> （不推荐）</p></li></ul><p><strong>4. 非 public 方法导致的事务失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 public 的</p></li><li><p>解法1：改为 public 方法</p></li><li><p>解法2：添加 bean 配置如下（不推荐）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TransactionAttributeSource <span class="title function_">transactionAttributeSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationTransactionAttributeSource</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 父子容器导致的事务失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day04.tx.app.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day04.tx.app.controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> Service5 service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        service.transfer(from, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;day04.tx.app.service&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ... 有事务相关配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Web 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;day04.tx.app&quot;)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ... 无事务配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在配置了父子容器，WebConfig 对应子容器，AppConfig 对应父容器，发现事务依然失效</p><ul><li><p>原因：子容器扫描范围过大，把未加事务配置的 service 扫描进来</p></li><li><p>解法1：各扫描各的，不要图简便</p></li><li><p>解法2：不要用父子容器，所有 bean 放在同一容器</p></li></ul><p><strong>6. 调用本类方法导致传播行为失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：本类方法调用不经过代理，因此无法增强</p></li><li><p>解法1：依赖注入自己（代理）来调用</p></li><li><p>解法2：通过 AopContext 拿到代理对象，来调用</p></li><li><p>解法3：通过 CTW，LTW 实现功能增强</p></li></ul><p>解法1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Service6 proxy; <span class="comment">// 本质上是一种循环依赖</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">System.out.println(proxy.getClass());</span><br><span class="line">proxy.bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2，还需要在 AppConfig 上添加 <code>@EnableAspectJAutoProxy(exposeProxy = true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        ((Service6) AopContext.currentProxy()).bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7. @Transactional 没有保证原子行为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(<span class="string">&quot;更新前查询余额为: &#123;&#125;&quot;</span>, fromBalance);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBalance</span><span class="params">(<span class="type">int</span> accountNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实际上是有 bug 的，假设 from 余额为 1000，两个线程都来转账 1000，可能会出现扣减为负数的情况</p><ul><li>原因：事务的原子性仅涵盖 insert、update、delete、select … for update 语句，select 方法并不阻塞</li></ul><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903120436365.png" alt="image-20210903120436365" style="zoom: 50%;"><ul><li>如上图所示，红色线程和蓝色线程的查询都发生在扣减之前，都以为自己有足够的余额做扣减</li></ul><p><strong>8. @Transactional 方法导致的 synchronized 失效</strong></p><p>针对上面的问题，能否在方法上加 synchronized 锁来解决呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(<span class="string">&quot;更新前查询余额为: &#123;&#125;&quot;</span>, fromBalance);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBalance</span><span class="params">(<span class="type">int</span> accountNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是不行，原因如下：</p><ul><li>synchronized 保证的仅是目标方法的原子性，环绕目标方法的还有 commit 等操作，它们并未处于 sync 块内</li><li>可以参考下图发现，蓝色线程的查询只要在红色线程提交之前执行，那么依然会查询到有 1000 足够余额来转账</li></ul><p><img src="/2023-02-26-cbddd37fc414/image-20210903120800185.png" alt="image-20210903120800185"></p><ul><li><p>解法1：synchronized 范围应扩大至代理方法调用</p></li><li><p>解法2：使用 select … for update 替换 select</p></li></ul><h2 id="5-Spring-MVC-执行流程"><a href="#5-Spring-MVC-执行流程" class="headerlink" title="5. Spring MVC 执行流程"></a>5. Spring MVC 执行流程</h2><p><strong>要求</strong></p><ul><li>掌握 Spring MVC 的执行流程</li><li>了解 Spring MVC 的重要组件的作用</li></ul><p><strong>概要</strong></p><p>我把整个流程分成三个阶段</p><ul><li>准备阶段</li><li>匹配阶段</li><li>执行阶段</li></ul><p><strong>准备阶段</strong></p><ol><li><p>在 Web 容器第一次用到 DispatcherServlet 的时候，会创建其对象并执行 init 方法</p></li><li><p>init 方法内会创建 Spring Web 容器，并调用容器 refresh 方法</p></li><li><p>refresh 过程中会创建并初始化 SpringMVC 中的重要组件， 例如 MultipartResolver，HandlerMapping，HandlerAdapter，HandlerExceptionResolver、ViewResolver 等</p></li><li><p>容器初始化后，会将上一步初始化好的重要组件，赋值给 DispatcherServlet 的成员变量，留待后用</p></li></ol><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903140657163.png" alt="image-20210903140657163" style="zoom: 80%;"><p><strong>匹配阶段</strong></p><ol><li><p>用户发送的请求统一到达前端控制器 DispatcherServlet</p></li><li><p>DispatcherServlet 遍历所有 HandlerMapping ，找到与路径匹配的处理器</p><p>① HandlerMapping 有多个，每个 HandlerMapping 会返回不同的处理器对象，谁先匹配，返回谁的处理器。其中能识别 @RequestMapping 的优先级最高</p><p>② 对应 @RequestMapping 的处理器是 HandlerMethod，它包含了控制器对象和控制器方法信息</p><p>③ 其中路径与处理器的映射关系在 HandlerMapping 初始化时就会建立好</p></li></ol><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903141017502.png" alt="image-20210903141017502" style="zoom:80%;"><ol start="3"><li>将 HandlerMethod 连同匹配到的拦截器，生成调用链对象 HandlerExecutionChain 返回</li></ol><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903141124911.png" alt="image-20210903141124911" style="zoom:80%;"><ol start="4"><li>遍历HandlerAdapter 处理器适配器，找到能处理 HandlerMethod 的适配器对象，开始调用</li></ol><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903141204799.png" alt="image-20210903141204799" style="zoom:80%;"><p><strong>调用阶段</strong></p><ol><li>执行拦截器 preHandle</li></ol><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903141445870.png" alt="image-20210903141445870" style="zoom: 67%;"><ol start="2"><li><p>由 HandlerAdapter 调用 HandlerMethod</p><p>① 调用前处理不同类型的参数</p><p>② 调用后处理不同类型的返回值</p></li></ol><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903141658199.png" alt="image-20210903141658199" style="zoom:67%;"><ol start="3"><li><p>第 2 步没有异常</p><p>① 返回 ModelAndView</p><p>② 执行拦截器 postHandle 方法</p><p>③ 解析视图，得到 View 对象，进行视图渲染</p></li></ol><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903141749830.png" alt="image-20210903141749830" style="zoom:67%;"><ol start="4"><li>第 2 步有异常，进入 HandlerExceptionResolver 异常处理流程</li></ol><img src="/2023-02-26-cbddd37fc414/../../../../文档/资料/JavaEE/讲义/Java面试专题讲义/img/image-20210903141844185.png" alt="image-20210903141844185" style="zoom:67%;"><ol start="5"><li><p>最后都会执行拦截器的 afterCompletion 方法</p></li><li><p>如果控制器方法标注了 @ResponseBody 注解，则在第 2 步，就会生成 json 结果，并标记 ModelAndView 已处理，这样就不会执行第 3 步的视图渲染</p></li></ol><h2 id="6-Spring-注解"><a href="#6-Spring-注解" class="headerlink" title="6. Spring 注解"></a>6. Spring 注解</h2><p><strong>要求</strong></p><ul><li>掌握 Spring 常见注解</li></ul><blockquote><p><em><strong>提示</strong></em></p><ul><li>注解的详细列表请参考：面试题-spring-注解.xmind</li><li>下面列出了视频中重点提及的注解，考虑到大部分注解同学们已经比较熟悉了，仅对个别的作简要说明</li></ul></blockquote><p><strong>事务注解</strong></p><ul><li>@EnableTransactionManagement，会额外加载 4 个 bean<ul><li>BeanFactoryTransactionAttributeSourceAdvisor 事务切面类</li><li>TransactionAttributeSource 用来解析事务属性</li><li>TransactionInterceptor 事务拦截器</li><li>TransactionalEventListenerFactory 事务监听器工厂</li></ul></li><li>@Transactional</li></ul><p><strong>核心</strong></p><ul><li>@Order</li></ul><p><strong>切面</strong></p><ul><li>@EnableAspectJAutoProxy<ul><li>会加载 AnnotationAwareAspectJAutoProxyCreator，它是一个 bean 后处理器，用来创建代理</li><li>如果没有配置 @EnableAspectJAutoProxy，又需要用到代理（如事务）则会使用 InfrastructureAdvisorAutoProxyCreator 这个 bean 后处理器</li></ul></li></ul><p><strong>组件扫描与配置类</strong></p><ul><li><p>@Component</p></li><li><p>@Controller</p></li><li><p>@Service</p></li><li><p>@Repository</p></li><li><p>@ComponentScan</p></li><li><p>@Conditional </p></li><li><p>@Configuration</p><ul><li>配置类其实相当于一个工厂, 标注 @Bean 注解的方法相当于工厂方法</li><li>@Bean 不支持方法重载, 如果有多个重载方法, 仅有一个能入选为工厂方法</li><li>@Configuration 默认会为标注的类生成代理, 其目的是保证 @Bean 方法相互调用时, 仍然能保证其单例特性</li><li>@Configuration 中如果含有 BeanFactory 后处理器, 则实例工厂方法会导致 MyConfig 提前创建, 造成其依赖注入失败，解决方法是改用静态工厂方法或直接为 @Bean 的方法参数依赖注入, 针对 Mapper 扫描可以改用注解方式</li></ul></li><li><p>@Bean</p></li><li><p>@Import </p><ul><li><p>四种用法</p><p>① 引入单个 bean</p><p>② 引入一个配置类</p><p>③ 通过 Selector 引入多个类</p><p>④ 通过 beanDefinition 注册器</p></li><li><p>解析规则</p><ul><li>同一配置类中, @Import 先解析  @Bean 后解析</li><li>同名定义, 默认后面解析的会覆盖前面解析的</li><li>不允许覆盖的情况下, 如何能够让 MyConfig(主配置类) 的配置优先? (虽然覆盖方式能解决)</li><li>采用 DeferredImportSelector，因为它最后工作, 可以简单认为先解析 @Bean, 再 Import</li></ul></li></ul></li><li><p>@Lazy</p><ul><li>加在类上，表示此类延迟实例化、初始化</li><li>加在方法参数上，此参数会以代理方式注入</li></ul></li><li><p>@PropertySource</p></li></ul><p><strong>依赖注入</strong></p><ul><li>@Autowired</li><li>@Qualifier</li><li>@Value</li></ul><p><strong>mvc mapping</strong></p><ul><li>@RequestMapping，可以派生多个注解如 @GetMapping 等</li></ul><p><strong>mvc rest</strong></p><ul><li>@RequestBody</li><li>@ResponseBody，组合 @Controller &#x3D;&gt;  @RestController</li><li>@ResponseStatus</li></ul><p><strong>mvc 统一处理</strong></p><ul><li>@ControllerAdvice，组合 @ResponseBody &#x3D;&gt; @RestControllerAdvice</li><li>@ExceptionHandler</li></ul><p><strong>mvc 参数</strong></p><ul><li>@PathVariable</li></ul><p><strong>mvc ajax</strong></p><ul><li>@CrossOrigin</li></ul><p><strong>boot auto</strong></p><ul><li>@SpringBootApplication</li><li>@EnableAutoConfiguration</li><li>@SpringBootConfiguration</li></ul><p><strong>boot condition</strong></p><ul><li>@ConditionalOnClass，classpath 下存在某个 class 时，条件才成立</li><li>@ConditionalOnMissingBean，beanFactory 内不存在某个 bean 时，条件才成立</li><li>@ConditionalOnProperty，配置文件中存在某个 property（键、值）时，条件才成立</li></ul><p><strong>boot properties</strong></p><ul><li>@ConfigurationProperties，会将当前 bean 的属性与配置文件中的键值进行绑定</li><li>@EnableConfigurationProperties，会添加两个较为重要的 bean<ul><li>ConfigurationPropertiesBindingPostProcessor，bean 后处理器，在 bean 初始化前调用下面的 binder</li><li>ConfigurationPropertiesBinder，真正执行绑定操作</li></ul></li></ul><h2 id="7-SpringBoot-自动配置原理"><a href="#7-SpringBoot-自动配置原理" class="headerlink" title="7. SpringBoot 自动配置原理"></a>7. SpringBoot 自动配置原理</h2><p><strong>要求</strong></p><ul><li>掌握 SpringBoot 自动配置原理</li></ul><p><strong>自动配置原理</strong></p><p>@SpringBootConfiguration 是一个组合注解，由 @ComponentScan、@EnableAutoConfiguration 和 @SpringBootConfiguration 组成</p><ol><li><p>@SpringBootConfiguration 与普通 @Configuration 相比，唯一区别是前者要求整个 app 中只出现一次</p></li><li><p>@ComponentScan</p><ul><li>excludeFilters - 用来在组件扫描时进行排除，也会排除自动配置类</li></ul></li><li><p>@EnableAutoConfiguration 也是一个组合注解，由下面注解组成</p><ul><li>@AutoConfigurationPackage – 用来记住扫描的起始包</li><li>@Import(AutoConfigurationImportSelector.class) 用来加载 <code>META-INF/spring.factories</code> 中的自动配置类</li></ul></li></ol><p><strong>为什么不使用 @Import 直接引入自动配置类</strong></p><p>有两个原因：</p><ol><li>让主配置类和自动配置类变成了强耦合，主配置类不应该知道有哪些从属配置</li><li>直接用 <code>@Import(自动配置类.class)</code>，引入的配置解析优先级较高，自动配置类的解析应该在主配置没提供时作为默认配置</li></ol><p>因此，采用了 <code>@Import(AutoConfigurationImportSelector.class)</code></p><ul><li>由 <code>AutoConfigurationImportSelector.class</code> 去读取 <code>META-INF/spring.factories</code> 中的自动配置类，实现了弱耦合。</li><li>另外 <code>AutoConfigurationImportSelector.class</code> 实现了 DeferredImportSelector 接口，让自动配置的解析晚于主配置的解析</li></ul><h2 id="8-Spring-中的设计模式"><a href="#8-Spring-中的设计模式" class="headerlink" title="8. Spring 中的设计模式"></a>8. Spring 中的设计模式</h2><p><strong>要求</strong></p><ul><li>掌握 Spring 中常见的设计模式</li></ul><p><strong>1. Spring 中的 Singleton</strong></p><p>请大家区分 singleton pattern 与 Spring 中的 singleton bean</p><ul><li>根据单例模式的目的 <em>Ensure a class only has one instance, and provide a global point of access to it</em> </li><li>显然 Spring 中的 singleton bean 并非实现了单例模式，singleton bean 只能保证每个容器内，相同 id 的 bean 单实例</li><li>当然 Spring 中也用到了单例模式，例如<ul><li>org.springframework.transaction.TransactionDefinition#withDefaults</li><li>org.springframework.aop.TruePointcut#INSTANCE</li><li>org.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR</li><li>org.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE</li><li>org.springframework.core.OrderComparator#INSTANCE</li></ul></li></ul><p><strong>2. Spring 中的 Builder</strong></p><p>定义 <em>Separate the construction of a complex object from its representation so that the same construction process can create different representations</em> </p><p>它的主要亮点有三处：</p><ol><li><p>较为灵活的构建产品对象</p></li><li><p>在不执行最后 build 方法前，产品对象都不可用</p></li><li><p>构建过程采用链式调用，看起来比较爽</p></li></ol><p>Spring 中体现 Builder 模式的地方：</p><ul><li><p>org.springframework.beans.factory.support.BeanDefinitionBuilder</p></li><li><p>org.springframework.web.util.UriComponentsBuilder</p></li><li><p>org.springframework.http.ResponseEntity.HeadersBuilder</p></li><li><p>org.springframework.http.ResponseEntity.BodyBuilder</p></li></ul><p><strong>3. Spring 中的 Factory Method</strong></p><p>定义 <em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses</em> </p><p>根据上面的定义，Spring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法，它隐藏了 bean （产品）的创建过程和具体实现</p><p>Spring 中其它工厂：</p><ul><li><p>org.springframework.beans.factory.FactoryBean</p></li><li><p>@Bean 标注的静态方法及实例方法</p></li><li><p>ObjectFactory 及 ObjectProvider</p></li></ul><p>前两种工厂主要封装第三方的 bean 的创建过程，后两种工厂可以推迟 bean 创建，解决循环依赖及单例注入多例等问题</p><p><strong>4. Spring 中的 Adapter</strong></p><p>定义 <em>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces</em> </p><p>典型的实现有两处：</p><ul><li>org.springframework.web.servlet.HandlerAdapter – 因为控制器实现有各种各样，比如有<ul><li>大家熟悉的 @RequestMapping 标注的控制器实现</li><li>传统的基于 Controller 接口（不是 @Controller注解啊）的实现</li><li>较新的基于 RouterFunction 接口的实现</li><li>它们的处理方法都不一样，为了统一调用，必须适配为 HandlerAdapter 接口</li></ul></li><li>org.springframework.beans.factory.support.DisposableBeanAdapter – 因为销毁方法多种多样，因此都要适配为 DisposableBean 来统一调用销毁方法</li></ul><p><strong>5. Spring 中的 Composite</strong></p><p>定义 <em>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly</em> </p><p>典型实现有：</p><ul><li>org.springframework.web.method.support.HandlerMethodArgumentResolverComposite</li><li>org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite</li><li>org.springframework.web.servlet.handler.HandlerExceptionResolverComposite</li><li>org.springframework.web.servlet.view.ViewResolverComposite</li></ul><p>composite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是，与具体干活的实现实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的实现来完成</p><p><strong>6. Spring 中的 Decorator</strong></p><p>定义 <em>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality</em> </p><p>典型实现：</p><ul><li>org.springframework.web.util.ContentCachingRequestWrapper</li></ul><p><strong>7. Spring 中的 Proxy</strong></p><p>定义 <em>Provide a surrogate or placeholder for another object to control access to it</em> </p><p>装饰器模式注重的是功能增强，避免子类继承方式进行功能扩展，而代理模式更注重控制目标的访问</p><p>典型实现：</p><ul><li>org.springframework.aop.framework.JdkDynamicAopProxy</li><li>org.springframework.aop.framework.ObjenesisCglibAopProxy</li></ul><p><strong>8. Spring 中的 Chain of Responsibility</strong></p><p>定义 <em>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it</em> </p><p>典型实现：</p><ul><li>org.springframework.web.servlet.HandlerInterceptor</li></ul><p><strong>9. Spring 中的 Observer</strong></p><p>定义 <em>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically</em> </p><p>典型实现：</p><ul><li>org.springframework.context.ApplicationListener</li><li>org.springframework.context.event.ApplicationEventMulticaster</li><li>org.springframework.context.ApplicationEvent</li></ul><p><strong>10. Spring 中的 Strategy</strong></p><p>定义 <em>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it</em> </p><p>典型实现：</p><ul><li>org.springframework.beans.factory.support.InstantiationStrategy</li><li>org.springframework.core.annotation.MergedAnnotations.SearchStrategy</li><li>org.springframework.boot.autoconfigure.condition.SearchStrategy</li></ul><p><strong>11. Spring 中的 Template Method</strong></p><p>定义 <em>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure</em> </p><p>典型实现：</p><ul><li>大部分以 Template 命名的类，如 JdbcTemplate，TransactionTemplate</li><li>很多以 Abstract 命名的类，如 AbstractApplicationContext</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;框架篇&quot;&gt;&lt;a href=&quot;#框架篇&quot; class=&quot;headerlink&quot; title=&quot;框架篇&quot;&gt;&lt;/a&gt;框架篇&lt;/h1&gt;&lt;h2 id=&quot;1-Spring-refresh-流程&quot;&gt;&lt;a href=&quot;#1-Spring-refresh-流程&quot; class=&quot;he</summary>
      
    
    
    
    <category term="面试题" scheme="https://zhuxuchen.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://zhuxuchen.github.io/tags/Java/"/>
    
    <category term="面试题" scheme="https://zhuxuchen.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架整合</title>
    <link href="https://zhuxuchen.github.io/2023-02-24-a06be7881aee/"/>
    <id>https://zhuxuchen.github.io/2023-02-24-a06be7881aee/</id>
    <published>2023-02-24T06:56:40.000Z</published>
    <updated>2023-02-25T08:58:08.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目演示与功能介绍"><a href="#项目演示与功能介绍" class="headerlink" title="项目演示与功能介绍"></a>项目演示与功能介绍</h1><ol><li>注册登录</li><li>用户管理</li><li>权限管理</li><li>客户管理</li><li>新闻发布</li><li>统计分析</li></ol><p>7、后台管理<br><img src="/2023-02-24-a06be7881aee/image.png"></p><p><img src="/2023-02-24-a06be7881aee/image-1677222076408.png"></p><p><img src="/2023-02-24-a06be7881aee/image-1677222078555.png"></p><h1 id="开发所需环境"><a href="#开发所需环境" class="headerlink" title="开发所需环境"></a>开发所需环境</h1><ol><li>JDK1.8</li><li>IDEA(2021.2.1)</li><li>Maven</li><li>MySQL5.6</li><li>Navicat</li><li>Tomcat9</li></ol><h1 id="项目核心技术"><a href="#项目核心技术" class="headerlink" title="项目核心技术"></a>项目核心技术</h1><ol><li>HTML5</li><li>jQuery</li><li>AJAX</li><li>BootStrap</li><li>MySQL</li><li>SSM</li><li>SpringBoot</li><li>JSP</li><li>ECharts</li></ol><h1 id="技术参考资料"><a href="#技术参考资料" class="headerlink" title="技术参考资料"></a>技术参考资料</h1><p>在此，介绍本项目开发环境以及所涉技术参考资料。</p><p>备注说明：</p><ol><li>请各位同学检查自己的开发环境</li><li>已经具备J2EE开发环境的同学非必要情况下不必重新搭建开发环境</li></ol><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>关于JDK的安装请参见文档 <a href="https://blog.csdn.net/lfdfhl/article/details/91441681">https://blog.csdn.net/lfdfhl/article/details/91441681</a><br>您只需要关注该文档中的JDK安装部分的教程，其余部分请忽略。</p><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>关于IDEA的安装教程请参见文档 <a href="https://blog.csdn.net/lfdfhl/article/details/125387986">https://blog.csdn.net/lfdfhl/article/details/125387986</a></p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>关于Maven的安装请参见文档 <a href="https://blog.csdn.net/lfdfhl/article/details/91441681">https://blog.csdn.net/lfdfhl/article/details/91441681</a><br>您只需要关注该文档中的Maven安装部分的教程，其余部分请忽略。<br>我们的项目开发使用的是IDEA而非eclipse；所以，关于Eclipse中Maven的配置、使用、项目开发亦请忽略。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>关于MySQL的安装请参见文档 <a href="https://blog.csdn.net/lfdfhl/article/details/91441681">https://blog.csdn.net/lfdfhl/article/details/91441681</a><br>您只需要关注该文档中的MySQL安装部分的教程，其余部分请忽略。</p><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>关于jQuery的使用请参考文档 <a href="https://blog.csdn.net/lfdfhl/category_10863887.html">https://blog.csdn.net/lfdfhl/category_10863887.html</a></p><h2 id="SpringBoot整合教程"><a href="#SpringBoot整合教程" class="headerlink" title="SpringBoot整合教程"></a>SpringBoot整合教程</h2><p>关于SpringBoot整合SSM框架请参考文档 <a href="https://blog.csdn.net/lfdfhl/article/details/124741090">https://blog.csdn.net/lfdfhl/article/details/124741090</a></p><h1 id="SpringBoot核心技术回顾"><a href="#SpringBoot核心技术回顾" class="headerlink" title="SpringBoot核心技术回顾"></a>SpringBoot核心技术回顾</h1><p>Spring Boot是Spring大家族的子项目，其设计初衷在于简化Spring配置、快速构建项目、从而提升开发效率。Spring Boot不是Spring的替代解决方案；Spring Boot本身并不提供Spring的核心特征及扩展功能，只是用于快速且敏捷地开发基于Spring的应用程序。在开发过程中遵循”约定优于配置 convention over configuration”的思想来摆脱Spring的繁琐配置。另外，Spring Boot集成了大量常用的第三方库，而且使用方式非常简单和高效，几乎是开箱可用(out-of-the-box)。</p><p>简单地说：Spring Boot设计的目的用于简化Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过该方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><p>关于Spring Boot的详尽介绍请参见其官方网站 <a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p><h2 id="Spring-Boot优点"><a href="#Spring-Boot优点" class="headerlink" title="Spring Boot优点"></a>Spring Boot优点</h2><p>在此，简述Spring Boot的显著优点。</p><p>1、快速构建独立的Spring应用<br>Spring Boot依靠注解实现自动化配置。在构建应用时，我们只需添加相应的场景依赖，Spring Boot就会根据该场景依赖自动进行相关配置。</p><p>2、内嵌Tomcat、Jetty和Undertow服务器(无需部署WAR文件)<br>在以往传统的Spring开发部署时常需要将应用打成WAR包并部署至服务器(例如：Tomcat)。Spring Boot内嵌了Tomcat、Jetty和Undertow服务器并可自动将项目打包部署。</p><p>3、通过依赖启动器简化构建配置<br>在Spring Boot项目构建过程中无须准备jar文件，只需要依据场景需求选择对应的依赖启动器starter即可，该starter会自动下载相关jar文件。例如，在Web开发时只需选择相应的Web场景依赖启动器spring-boot-starter-web，Spring Boot便会自动导入spring-webmvc、spring-web、spring-boot-starter-tomcat等子依赖并自动下载相关jar文件。</p><p>4、自动化配置Spring和第三方库<br>Spring Boot对于第三方库的支持非常友好。在提供各种场景依赖其的基础上，在其内部还默认提供了各种自动化配置类。也就是说：在使用Spring Boot时一旦引入了某个场景的依赖启动器，Spring Boot内部提供的默认自动化配置类就会立即生效。所以，开发者无需再手动进行配置。</p><p>5、提供生产就绪<br>Spring Boot提供用于生产环境运行时的特征，例如：指标、健康监测、外部化配置等。</p><p>6、极少的代码生成和XML配置<br>Spring Boot内实现与Spring以及其他常用第三方库的整合连接，并提供了默认最优化的整合配置。所以，在使用Spring Boot时基本不需要额外的代码和XML配置。</p><p>7、避免容器污染。在以往的SSM项目中Spring容器与SpringMVC容器存在父子关系；假若使用不当容易导致容器污染。但是，在Spring Boot中Spring与SpringMVC均在同一个Spring Boot容器中不存在父容器与子容器的关系，从而避免了容器的污染。</p><h2 id="Spring-Boot本质"><a href="#Spring-Boot本质" class="headerlink" title="Spring Boot本质"></a>Spring Boot本质</h2><p>Spring Boot(微框架) &#x3D; SpringMVC(控制器) + Spring Core(项目管理)</p><h1 id="MyBatis基础核心技术回顾"><a href="#MyBatis基础核心技术回顾" class="headerlink" title="MyBatis基础核心技术回顾"></a>MyBatis基础核心技术回顾</h1><p>在此，简要回顾MyBatis基础核心技术。</p><h2 id="传递和接收单个普通类型参数"><a href="#传递和接收单个普通类型参数" class="headerlink" title="传递和接收单个普通类型参数"></a>传递和接收单个普通类型参数</h2><p>在MyBatis中可直接传递基本类型，基本类型的包装类型，字符串等。<br>在此方式下，xxxMapper.xml中的占位符#{ }里可使用任意字符接收传递过来的参数。<br>但是，为提高代码的可读性，建议与原参数名保持一致。</p><h2 id="利用-Param注解传递和接收多个普通类型参数"><a href="#利用-Param注解传递和接收多个普通类型参数" class="headerlink" title="利用@Param注解传递和接收多个普通类型参数"></a>利用@Param注解传递和接收多个普通类型参数</h2><p>在传递多个普通类型参数时我们可通过#{0}、#{1}、…#{N}或#{param1}、#{param2}、…#{paramN}的方式来接收。这样的写法不但效率低，而且代码可读性不强。为解决此问题，我们在传递参数时可使用@Param注解为参数起别名，再由MyBatis将这些参数的别名封装进Map中。于是，在接收端便可使用 #{别名}接收参数。</p><h2 id="传递和接收单个pojo作为参数"><a href="#传递和接收单个pojo作为参数" class="headerlink" title="传递和接收单个pojo作为参数"></a>传递和接收单个pojo作为参数</h2><p>当传递的参数是单个pojo时，映射文件的占位符中可使用#{pojo的属性名}的形式获取对应参数。</p><h2 id="传递和接收多个pojo作为参数-了解"><a href="#传递和接收多个pojo作为参数-了解" class="headerlink" title="传递和接收多个pojo作为参数(了解)"></a>传递和接收多个pojo作为参数(了解)</h2><p>当传递的参数是多个pojo时，映射文件的占位符中可使用#{paramN.pojo的属性名}的形式获取对应参数。</p><h2 id="查询单条数据并将结果封装至Map"><a href="#查询单条数据并将结果封装至Map" class="headerlink" title="查询单条数据并将结果封装至Map"></a>查询单条数据并将结果封装至Map</h2><p>依据id查询用户，将查询结果封装至Map。其中，字段(属性名)作为Map的键，字段对应的值作为Map的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依据id查询用户并将员工信息封装至Map</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">queryUserMapById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依据id查询用户并将员工信息封装至Map</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">queryUserMapById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><h2 id="查询所有数据并将结果封装至Map"><a href="#查询所有数据并将结果封装至Map" class="headerlink" title="查询所有数据并将结果封装至Map"></a>查询所有数据并将结果封装至Map</h2><p>依据查询所有用户，将查询结果封装至同一个Map。其中，以用户的id作为Map的键，以id所属的JavaBean作为Map的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;Integer, Object&gt; <span class="title function_">queryAllUserMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>在此，使用@MapKey注解指定哪个字段作为键。在该示例中，返回值为Map集合。其中；在Map中键为用户id，值为与id对应的用户对象</p><h1 id="SpringMVC基础核心技术回顾"><a href="#SpringMVC基础核心技术回顾" class="headerlink" title="SpringMVC基础核心技术回顾"></a>SpringMVC基础核心技术回顾</h1><p>在此，简要回顾SpringMVC基础核心技术。</p><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>@RequestMapping注解用于配置请求映射，即把请求与Controller中的方法进行映射。<br>一般情况下，Spring MVC 使用@RequestMapping 注解为Controller或Controller中的方法指定可以处理哪些 URL 请求。</p><p>@RequestMapping常用属性及其作用如下：</p><p>value：设置请求路径<br>method：设置请求方式<br>params：设置客户端传至服务器的数据<br>headers：设置请求头</p><p>Spring4.3中引进了一系列组合注解来帮助简化常用的HTTP方法的映射，例如：<br>@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping等等。</p><p>其中：<br>GetMapping相当于RequestMapping（method &#x3D; RequestMethod.GET）<br>PostMapping相当于RequestMapping（method &#x3D; RequestMethod.POST）<br>其余类似，不再赘述</p><h2 id="接收普通请求参数"><a href="#接收普通请求参数" class="headerlink" title="接收普通请求参数"></a>接收普通请求参数</h2><p>在URL请求中可通过键值对的形式向服务端传递请求参数。在此情况下可在Controller中的方法上利用形参接收URL中的请求参数。</p><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>测试路径</p><p><a href="http://localhost:8080/SpringMVC005/MyController1/test1.do?username=zxx">http://localhost:8080/SpringMVC005/MyController1/test1.do?username=zxx</a></p><p>示例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/test1.do&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">handleRequest1</span><span class="params">(String username, Model model)</span> &#123;</span><br><span class="line">   model.addAttribute(<span class="string">&quot;msg&quot;</span>, username);</span><br><span class="line">   <span class="type">String</span> <span class="variable">viewName</span> <span class="operator">=</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> viewName;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong><br>形参中的参数名应与URL地址中的参数名称应该保持一致。</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>除了之前的方式以外，我们还可以在Controller中方法的形参上使用@RequestParam注解接收URL中的请求参数。</p><p>测试路径</p><p><a href="http://localhost:8080/SpringMVC005/MyController1/test2.do?username=zxx">http://localhost:8080/SpringMVC005/MyController1/test2.do?username=zxx</a></p><p>示例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/test2.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleRequest2</span><span class="params">(<span class="meta">@RequestParam(value = &quot;username&quot;, required = false)</span> String name, Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, name);</span><br><span class="line">    <span class="type">String</span> <span class="variable">viewName</span> <span class="operator">=</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> viewName;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在该示例中接收前端传递的username并将其赋值给String类型的形参name。</p><p>注意事项</p><p>@RequestParam注解除了value属性以外还有required和defaultValue属性。required属性表示请求地址中参数是否必须包含某参数，其默认值为true。</p><h2 id="占位符映射-了解"><a href="#占位符映射-了解" class="headerlink" title="占位符映射(了解)"></a>占位符映射(了解)</h2><p>请求url如下：<br><a href="http://localhost:8080/SpringMVC003/MyController3/test1/9527/zxx">http://localhost:8080/SpringMVC003/MyController3/test1/9527/zxx</a></p><p>Controller如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;MyController3&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController3</span> &#123;</span><br><span class="line"><span class="comment">//占位符映射</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;test1/&#123;userid&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span> <span class="params">(<span class="meta">@PathVariable(&quot;userid&quot;)</span> Long id,<span class="meta">@PathVariable(&quot;username&quot;)</span> String name)</span>&#123;</span><br><span class="line"><span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">String msg=<span class="string">&quot;id=&quot;</span>+id+<span class="string">&quot;,name=&quot;</span>+name;</span><br><span class="line">modelAndView.addObject(<span class="string">&quot;msg&quot;</span>, msg);</span><br><span class="line">modelAndView.setViewName(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限定请求参数-了解"><a href="#限定请求参数-了解" class="headerlink" title="限定请求参数(了解)"></a>限定请求参数(了解)</h2><p>在Spring MVC中可使用@RequestMapping注解的params属性限定URL中参数的设置；并可利用@RequestParam注解获取参数值。@RequestParam的使用方式与@PathVariable非常类似，在此不再赘述。</p><h2 id="接收表单传递的基本数据类型"><a href="#接收表单传递的基本数据类型" class="headerlink" title="接收表单传递的基本数据类型"></a>接收表单传递的基本数据类型</h2><p>表单传递数据，Controller原样接收即可。</p><p>请注意：表单中控件的name属性的值与Controller中处理请求的方法的形参名保持一致。</p><p>示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/MyController1/test1.do&quot;</span><span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  编号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span> </span><br><span class="line">  姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/test1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleRequest1</span><span class="params">(Integer id,String name,Model model)</span>&#123;</span><br><span class="line">    String msg=<span class="string">&quot;id=&quot;</span>+id+<span class="string">&quot;,name=&quot;</span>+name;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, msg);</span><br><span class="line">    String viewName=<span class="string">&quot;result&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> viewName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将表单传递的数据绑定至POJO"><a href="#将表单传递的数据绑定至POJO" class="headerlink" title="将表单传递的数据绑定至POJO"></a>将表单传递的数据绑定至POJO</h2><p>表单传递数据，Controller将数据封装为POJO。</p><p>请注意：表单中各个控件的name属性的值与Controller中处理请求的方法的POJO形参的各属性保持一致。</p><p>示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/MyController1/test3.do&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">编号： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">地址：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递POJO类型参数，即将页面数据封装成POJO</span></span><br><span class="line"><span class="comment">//表单中各name属性的值与User的属性保持一致</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/test3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleRequest3</span><span class="params">(User user,Model model)</span>&#123;</span><br><span class="line">    String msg=user.toString();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, msg);</span><br><span class="line">    String viewName=<span class="string">&quot;result&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> viewName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模型与视图"><a href="#模型与视图" class="headerlink" title="模型与视图"></a>模型与视图</h2><p>Spring MVC在每次处理请求前都会默认地创建模型。所以，我们可在Controller方法的形参中声明这些模型与视图并且在方法体中使用模型存储数据或指定视图。</p><p>常见的模型与视图如下：</p><p>ModelAndView<br>Model<br>ModelMap<br>Map</p><p>其中，ModelAndView类用于存储数据并指定视图；Model定义了数据存储的相关方法。</p><p><strong>小结</strong><br>其实，在Controller中不管我们选择的是Model还是ModelMap还是Map来存储数据；最终，Spring MVC 内部均将它们装配成 ModelAndView 对象。</p><p>在Controller中存储的数据到底被保存到哪里了呢？答案是：request域。</p><h2 id="重定向与请求转发"><a href="#重定向与请求转发" class="headerlink" title="重定向与请求转发"></a>重定向与请求转发</h2><p>在Spring MVC中当视图名称字以 forward: 或者 redirect: 开头则会被认为是请求转发或者重定向。</p><p>重定向语法如下：</p><p>按照绝对路径重定向  redirect:&#x2F;Controller名&#x2F;xxx?key1&#x3D;value1&amp;key2&#x3D;value2<br>按照相对路径重定向  redirect:xxx?key1&#x3D;value1&amp;key2&#x3D;value2</p><p>除此外，我们依然可以使用HttpServletResponse实现重定向。</p><p>请求转发语法如下：</p><p>按照绝对路径请求转发  forward:&#x2F;Controller名&#x2F;xxx?key1&#x3D;value1&amp;key2&#x3D;value2<br>按照相对路径请求转发  forward:xxx?key1&#x3D;value1&amp;key2&#x3D;value2</p><h2 id="JSON数据交互"><a href="#JSON数据交互" class="headerlink" title="JSON数据交互"></a>JSON数据交互</h2><p>在数据交互过程中，有时浏览器发送给服务器的请求数据是JSON格式；类似地，服务器返回给浏览器的数据也可能是JSON格式。为了支持JSON格式的数据交互Spring MVC提供了@RequestBody和@ResponseBody注解来处理JSON数据。</p><p>@RequestBody注解用于读取HTTP请求的内容，通过Spring MVC提供的HttpMessageConverter接口将读到的JSON数据转换为POJO并绑定到Controller中方法的参数上。</p><p>@ResponseBody注解用于将Controller中方法的返回对象通过HttpMessageConverter接口转为JSON格式后再响应给客户端。</p><h1 id="开发框架搭建"><a href="#开发框架搭建" class="headerlink" title="开发框架搭建"></a>开发框架搭建</h1><p>请在IDEA中创建Maven项目并利用SpringBoot搭建项目开发框架并整合SSM。</p><p>请注意：开发框架搭建过程中所使用的代码均较为简易，在稍后项目正式开发中将对其进行替换。所以，建议删除此处的测试代码；否则，请在后续开发中细致地将其替换。</p><p>在完成SpringBoot整合SSM框架之后，我们正式进入项目的开发。</p><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><ol><li>请熟悉各表的字段及其含义</li><li>请执行项目SQL文件</li><li>请注意表字段与entity属性的对应</li></ol><p><strong>dictionary表如下：</strong><br><img src="/2023-02-24-a06be7881aee/image-1677222094981.png"><br><strong>Dictionary表要点概述：</strong></p><ol><li>id是主键</li><li>code不是唯一的。001表示客户行业，002表示客户来源，003表示客户级别</li><li>item是重点是每行数据的核心</li><li>可以理解为01表示教育培训，06表示电话营销，10表示重要客户</li></ol><p><strong>customer表要点概述：</strong></p><p><img src="/2023-02-24-a06be7881aee/image-1677222097683.png"></p><ol><li>客户表中的source 字段的值只可能来自于dictionary 的 id 06 07 08 </li><li>客户表中的industry字段的值只可能来自于dictionary 的 id 01 02 03 04 05</li><li>客户表中的level字段的值只可能来自于dictionary 的id 09 10</li></ol><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><p>请在pom.xml中添加如下项目依赖(假若之前已添加则忽略该步骤即可)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--web依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--test依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--MySQL依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--druid依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--MyBatis依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--分页依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jsp解析依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jstl依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--热部署依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jackson依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="准备后台通用配置"><a href="#准备后台通用配置" class="headerlink" title="准备后台通用配置"></a>准备后台通用配置</h1><ol><li>interceptor包中的LoginHandlerInterceptorImpl拦截器</li><li>config包中的配置类WebMvcConfigurerImpl</li><li>pojo包中的所有实体类</li><li>utils工具包中的Constants常量</li></ol><h1 id="准备前端页面资源"><a href="#准备前端页面资源" class="headerlink" title="准备前端页面资源"></a>准备前端页面资源</h1><p>拷贝前端页面以及相关资源至项目中(假若之前已添加则忽略该步骤即可)。</p><h1 id="数据字典模块"><a href="#数据字典模块" class="headerlink" title="数据字典模块"></a>数据字典模块</h1><p>在客户管理等模块常常使用数据字典，所以我们先进行数据字典模块的开发。</p><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p>请准备Dictionary</p><h2 id="DictionaryMapper-java接口文件"><a href="#DictionaryMapper-java接口文件" class="headerlink" title="DictionaryMapper.java接口文件"></a>DictionaryMapper.java接口文件</h2><p>要点概述：<br>1、依据编码查询字典数据<br>2、请在DictionaryMapper接口上使用**@Repository**注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DictionaryMapper</span> &#123;</span><br><span class="line">    <span class="comment">//依据编码查询字典数据</span></span><br><span class="line">    List&lt;Dictionary&gt; <span class="title function_">queryDictionarytByCode</span><span class="params">(String code)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DictionaryMapper-xml映射文件"><a href="#DictionaryMapper-xml映射文件" class="headerlink" title="DictionaryMapper.xml映射文件"></a>DictionaryMapper.xml映射文件</h2><p>要点概述：</p><ol><li>mapper namespace的值为”com.cn.crmsb.mapper.DictionaryMapper”</li><li>select 标签id的值为”queryDictionarytByCode”</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.cn.crmsb.mapper.DictionaryMapper&quot;</span> &gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 依据编码查询字典数据 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryDictionarytByCode&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;dictionary&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> &gt;</span></span><br><span class="line">    select * from dictionary where code = #&#123;code&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="DictionaryService"><a href="#DictionaryService" class="headerlink" title="DictionaryService"></a>DictionaryService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DictionaryService</span> &#123;</span><br><span class="line">    <span class="comment">//依据编码查询字典数据</span></span><br><span class="line">    List&lt;Dictionary&gt; <span class="title function_">queryDictionarytByCode</span><span class="params">(String code)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DictionaryServiceImpl"><a href="#DictionaryServiceImpl" class="headerlink" title="DictionaryServiceImpl"></a>DictionaryServiceImpl</h2><p>要点概述：</p><ol><li>DictionaryServiceImpl类实现DictionaryService接口</li><li>请在DictionaryServiceImpl类上使用@Service注解</li><li>请在DictionaryServiceImpl类中使用@Autowired注入DictionaryMapper</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;dictionaryService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DictionaryServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DictionaryService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DictionaryMapper dictionaryMapper;</span><br><span class="line">    <span class="comment">//依据编码查询字典数据</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dictionary&gt; <span class="title function_">queryDictionarytByCode</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dictionaryMapper.queryDictionarytByCode(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="客户管理模块"><a href="#客户管理模块" class="headerlink" title="客户管理模块"></a>客户管理模块</h1><h2 id="Customer"><a href="#Customer" class="headerlink" title="Customer"></a>Customer</h2><p>请准备Customer</p><h2 id="CustomerDto"><a href="#CustomerDto" class="headerlink" title="CustomerDto"></a>CustomerDto</h2><p>请准备CustomerDto</p><h2 id="CustomerMapper-java接口文件"><a href="#CustomerMapper-java接口文件" class="headerlink" title="CustomerMapper.java接口文件"></a>CustomerMapper.java接口文件</h2><p>注意事项：</p><ol><li>请注意使用@Repository注解</li><li>查询客户时以<strong>CustomerDto为查询条件</strong></li><li>查询客户比例的相关功能可稍后再实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询客户列表</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">queryCustomer</span><span class="params">(CustomerDto customerDto)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入客户</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertCustomer</span><span class="params">(Customer customer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依据ID查询客户</span></span><br><span class="line">    Customer <span class="title function_">queryCustomerById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新客户</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateCustomer</span><span class="params">(Customer customer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除客户</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteCustomer</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依据类型查询客户比例</span></span><br><span class="line">    <span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">queryCustomerProportionByType</span><span class="params">(String type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CustomerMapper-xml映射文件"><a href="#CustomerMapper-xml映射文件" class="headerlink" title="CustomerMapper.xml映射文件"></a>CustomerMapper.xml映射文件</h2><p>注意事项：</p><ol><li>请注意利用多表连接查询客户信息，尤其是客户来源、行业、等级等信息</li><li>请注意查询用户时以CustomerDto为查询条件</li><li>请注意查询的SQL片段</li><li>请在更新客户时使用set标签</li><li>查询客户属性的相关功能可稍后再实现</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.cn.crmsb.mapper.CustomerMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--SQL片段  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;queryCustomerWhere&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;customerName != null and customerName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        name like &quot;%&quot;#&#123;customerName&#125;&quot;%&quot;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;customerSourceID != null and customerSourceID != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and source = #&#123;customerSourceID&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;customerIndustryID != null and customerIndustryID != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and industry = #&#123;customerIndustryID&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;customerLevelID != null and customerLevelID != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and level = #&#123;customerLevelID&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 查询客户列表  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryCustomer&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;customerDto&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">    SELECT c.id, c.name, d1.item AS source, d2.item AS industry, d3.item AS level</span><br><span class="line">    , c.phone, c.manager, c.address, c.createtime</span><br><span class="line">    FROM customer AS c</span><br><span class="line">    LEFT JOIN dictionary AS d1 ON c.source = d1.id</span><br><span class="line">    LEFT JOIN dictionary AS d2 ON c.industry = d2.id</span><br><span class="line">    LEFT JOIN dictionary AS d3 ON c.level = d3.id</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;queryCustomerWhere&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 插入客户 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertCustomer&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">    insert into customer(name, source, industry, level, manager, phone, address, createtime)</span><br><span class="line">    values (#&#123;name&#125;, #&#123;source&#125;, #&#123;industry&#125;, #&#123;level&#125;, #&#123;manager&#125;, #&#123;phone&#125;, #&#123;address&#125;, #&#123;createtime&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 根据ID查询客户 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryCustomerById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from customer</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 更新客户 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateCustomer&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">    update customer</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null&quot;</span>&gt;</span></span><br><span class="line">        name=#&#123;name&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;source!=null&quot;</span>&gt;</span></span><br><span class="line">        source=#&#123;source&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;industry!=null&quot;</span>&gt;</span></span><br><span class="line">        industry=#&#123;industry&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;level!=null&quot;</span>&gt;</span></span><br><span class="line">        level=#&#123;level&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;manager!=null&quot;</span>&gt;</span></span><br><span class="line">        manager=#&#123;manager&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;phone!=null&quot;</span>&gt;</span></span><br><span class="line">        phone=#&#123;phone&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address!=null&quot;</span>&gt;</span></span><br><span class="line">        address=#&#123;address&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createtime!=null&quot;</span>&gt;</span></span><br><span class="line">        createtime=#&#123;createtime&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 删除客户 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteCustomer&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Integer&quot;</span>&gt;</span></span><br><span class="line">    delete</span><br><span class="line">    from customer</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 依据类型查询客户比例 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryCustomerProportionByType&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    SELECT d.item AS name, COUNT(customer.id) AS value</span><br><span class="line">    FROM customer</span><br><span class="line">    LEFT JOIN dictionary AS d</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;type == 002&quot;</span>&gt;</span></span><br><span class="line">        ON customer.source=d.id</span><br><span class="line">        where customer.source != &#x27;&#x27;</span><br><span class="line">        GROUP BY customer.source</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;type == 001&quot;</span>&gt;</span></span><br><span class="line">        ON customer.industry=d.id</span><br><span class="line">        where customer.industry != &#x27;&#x27;</span><br><span class="line">        GROUP BY customer.industry</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;type == 003&quot;</span>&gt;</span></span><br><span class="line">        ON customer.level=d.id</span><br><span class="line">        where customer.level != &#x27;&#x27;</span><br><span class="line">        GROUP BY customer.level</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CustomerService"><a href="#CustomerService" class="headerlink" title="CustomerService"></a>CustomerService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line">    <span class="comment">//查询客户列表</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">queryCustomer</span><span class="params">(CustomerDto customerDto)</span>;</span><br><span class="line">    <span class="comment">//插入客户</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertCustomer</span><span class="params">(Customer customer)</span>;</span><br><span class="line">    <span class="comment">//依据ID查询客户</span></span><br><span class="line">    Customer <span class="title function_">queryCustomerById</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="comment">//更新客户</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateCustomer</span><span class="params">(Customer customer)</span>;</span><br><span class="line">    <span class="comment">//删除客户</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteCustomer</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="comment">//依据类型查询客户比例</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">queryCustomerProportionByType</span><span class="params">(String type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CustomerServiceImpl"><a href="#CustomerServiceImpl" class="headerlink" title="CustomerServiceImpl"></a>CustomerServiceImpl</h2><p>注意事项：</p><ol><li>请在CustomerServiceImpl上使用@Service注解</li><li>请在CustomerServiceImpl上使用@Transactional注解</li><li>请在CustomerServiceImpl中使用@Autowired注入CustomerMapper</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;customerService&quot;)</span></span><br><span class="line"><span class="comment">// 事务管理</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CustomerMapper customerMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询客户列表</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Customer&gt; <span class="title function_">queryCustomer</span><span class="params">(CustomerDto customerDto)</span> &#123;</span><br><span class="line">List&lt;Customer&gt; customerList = customerMapper.queryCustomer(customerDto);</span><br><span class="line"><span class="keyword">return</span> customerList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入客户</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertCustomer</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> customerMapper.insertCustomer(customer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依据ID查询客户</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">queryCustomerById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> customerMapper.queryCustomerById(id);</span><br><span class="line"><span class="keyword">return</span> customer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新客户</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateCustomer</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> customerMapper.updateCustomer(customer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除客户</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteCustomer</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> customerMapper.deleteCustomer(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依据类型查询客户比例</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">queryCustomerProportionByType</span><span class="params">(String type)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> customerMapper.queryCustomerProportionByType(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CustomerController"><a href="#CustomerController" class="headerlink" title="CustomerController"></a>CustomerController</h2><p>在此，分别介绍CustomerController的主要功能。</p><h3 id="CustomerController类的定义及其属性"><a href="#CustomerController类的定义及其属性" class="headerlink" title="CustomerController类的定义及其属性"></a>CustomerController类的定义及其属性</h3><p>注意事项：</p><ol><li>请在CustomerController类上使用@Controller注解</li><li>请在CustomerController类上使用@RequestMapping注解</li><li>请在CustomerController类上使用@Autowired自动注入CustomerService和DictionaryService</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/customerController&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomerService customerService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DictionaryService dictionaryService;</span><br><span class="line"><span class="comment">//以下为各个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询客户"><a href="#查询客户" class="headerlink" title="查询客户"></a>查询客户</h3><p>客户查询涉及到：</p><p>注意事项：</p><ol><li>请在list方法上使用@RequestMapping注解</li><li>请在list方法上使用@RequestParam接收分页参数page</li><li>请在list方法上使用CustomerDto接收查询条件，该参数可为空；常用于带条件的查询</li><li>请在list方法中先查询出所有的来源、行业、级别以便在页面中将数据绑定至下拉框</li><li>请在list方法中保存已经有的查询条件便于查询结束后回显查询条件</li><li>请在list方法中实现分页查询</li><li>请在list方法末尾跳转至customer页面即return “customer”;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询客户列表</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">list</span><span class="params">(<span class="meta">@RequestParam(required = false, value = &quot;page&quot;, defaultValue = &quot;1&quot;)</span> Integer page, CustomerDto customerDto, Model model)</span> &#123;</span><br><span class="line">    <span class="comment">// 客户来源</span></span><br><span class="line">    List&lt;Dictionary&gt; sourceList = dictionaryService.queryDictionarytByCode(Constants.SOURCE_TYPE);</span><br><span class="line">    <span class="comment">// 客户所属行业</span></span><br><span class="line">    List&lt;Dictionary&gt; industryList = dictionaryService.queryDictionarytByCode(Constants.INDUSTRY_TYPE);</span><br><span class="line">    <span class="comment">// 客户级别</span></span><br><span class="line">    List&lt;Dictionary&gt; levelList = dictionaryService.queryDictionarytByCode(Constants.LEVEL_TYPE);</span><br><span class="line">    <span class="comment">// 保存数据至Model</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;sourceList&quot;</span>, sourceList);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;industryList&quot;</span>, industryList);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;levelList&quot;</span>, levelList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存查询条件至Model便于页面回显数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">customerName</span> <span class="operator">=</span> customerDto.getCustomerName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">customerSourceID</span> <span class="operator">=</span> customerDto.getCustomerSourceID();</span><br><span class="line">    <span class="type">String</span> <span class="variable">customerIndustryID</span> <span class="operator">=</span> customerDto.getCustomerIndustryID();</span><br><span class="line">    <span class="type">String</span> <span class="variable">customerLevelID</span> <span class="operator">=</span> customerDto.getCustomerLevelID();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;customerName&quot;</span>, customerName);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;customerSourceID&quot;</span>, customerSourceID);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;customerIndustryID&quot;</span>, customerIndustryID);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;customerLevelID&quot;</span>, customerLevelID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//page:表示查询第几页;8:表示每页显示的数量</span></span><br><span class="line">    PageHelper.startPage(page, <span class="number">8</span>);</span><br><span class="line">    List&lt;Customer&gt; customerList = customerService.queryCustomer(customerDto);</span><br><span class="line">    <span class="comment">//将customerList封装至PageInfo;5表示分页导航的最大页码数。</span></span><br><span class="line">    PageInfo&lt;Customer&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;Customer&gt;(customerList, <span class="number">5</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;pageInfo&quot;</span>, pageInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;customer&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改登录成功后的跳转"><a href="#修改登录成功后的跳转" class="headerlink" title="修改登录成功后的跳转"></a>修改登录成功后的跳转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定向至客户列表页面</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/customerController/list&quot;</span>;</span><br></pre></td></tr></table></figure><p>修改后请进行测试。</p><h3 id="customer-jsp-了解"><a href="#customer-jsp-了解" class="headerlink" title="customer.jsp(了解)"></a>customer.jsp(了解)</h3><p>要点概述：</p><p>点击超链接时依据data-target打开新的模态框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">data-toggle</span>=<span class="string">&quot;modal&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">data-target</span>=<span class="string">&quot;#newCustomerDialog&quot;</span>&gt;</span></span><br><span class="line">  新建</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击新增客户调用insertCustomer( )函数通过AJAX提交至后台</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;insertCustomer()&quot;</span>&gt;</span>新增客户<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击修改客户调用updateCustomer( )函数通过AJAX提交至后台</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;updateCustomer()&quot;</span>&gt;</span>保存修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在显示客户列表时根据域中的保存的值进行显示</p><p>登录后进入customerController 调用list 显示所有客户。即在不附带任何条件的基础下显示所有客户。</p><p>点击查询时再次进入customerController 调用list 显示所有客户。此时，是在附带条件的基础下显示满足条件的客户。</p><p>在查询完成后显示客户时还需要对查询条件进行回显。</p><h3 id="增加客户"><a href="#增加客户" class="headerlink" title="增加客户"></a>增加客户</h3><p>在插入客户之前需要查询中系统中的来源、行业、等级并绑定至新增用户的页面的下拉框。</p><p>注意事项：</p><ol><li>请在toInsert方法上使用@RequestMapping注解映射路径</li><li>请在toInsert方法末尾跳转至customer_insert，即return “customer_insert”;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备插入客户</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toInsert&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toInsert</span><span class="params">(Model model)</span> &#123;</span><br><span class="line"><span class="comment">// 客户来源</span></span><br><span class="line">List&lt;Dictionary&gt; sourceList = dictionaryService.queryDictionarytByCode(Constants.SOURCE_TYPE);</span><br><span class="line"><span class="comment">// 客户所属行业</span></span><br><span class="line">List&lt;Dictionary&gt; industryList = dictionaryService.queryDictionarytByCode(Constants.INDUSTRY_TYPE);</span><br><span class="line"><span class="comment">// 客户级别</span></span><br><span class="line">List&lt;Dictionary&gt; levelList = dictionaryService.queryDictionarytByCode(Constants.LEVEL_TYPE);</span><br><span class="line"><span class="comment">// 保存数据至Model</span></span><br><span class="line">model.addAttribute(<span class="string">&quot;sourceList&quot;</span>, sourceList);</span><br><span class="line">model.addAttribute(<span class="string">&quot;industryList&quot;</span>, industryList);</span><br><span class="line">model.addAttribute(<span class="string">&quot;levelList&quot;</span>, levelList);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;customer_insert&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在customer_insert页面填写数据后提交至该insertCustomer方法，其路径为&#x2F;insert。</p><p>注意事项：</p><ol><li>请在insertCustomer方法上使用@RequestMapping注解</li><li>请在insertCustomer方法上使用@ResponseBody注解将返回值以JSON格式返回至AJAX请求</li><li>该方法的返回值为Result</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入客户</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/insert&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">insertCustomer</span><span class="params">(Customer customer, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Timestamp</span> <span class="variable">timeStamp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timestamp</span>(time);</span><br><span class="line">    customer.setCreatetime(timeStamp);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> customerService.insertCustomer(customer);</span><br><span class="line">    <span class="keyword">if</span> (rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result.setStatus(Constants.OK);</span><br><span class="line">        result.setDescription(<span class="string">&quot;新增客户成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.setStatus(Constants.ERROR);</span><br><span class="line">        result.setDescription(<span class="string">&quot;新增客户失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依据id查询客户"><a href="#依据id查询客户" class="headerlink" title="依据id查询客户"></a>依据id查询客户</h3><p>注意事项：</p><ol><li>请在queryCustomerById方法上使用@RequestMapping注解</li><li>请在queryCustomerById方法上使用@ResponseBody注解将返回值以JSON格式返回至AJAX请求</li><li>该方法的返回值为Customer对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依据ID查询客户</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/queryCustomerById&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">queryCustomerById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> customerService.queryCustomerById(id);</span><br><span class="line">    <span class="keyword">return</span> customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改客户"><a href="#修改客户" class="headerlink" title="修改客户"></a>修改客户</h3><p>在修改客户之前需要查询中系统中的来源、行业、等级并绑定至新增用户的页面的下拉框。</p><p>注意事项：</p><ol><li>请在toUpdate方法上使用@RequestMapping注解映射路径</li><li>请在toUpdate方法末尾跳转至customer_update，即return “ customer_update t”;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备更新客户</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toUpdate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toUpdate</span><span class="params">(<span class="type">int</span> id, Model model)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> customerService.queryCustomerById(id);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;customer&quot;</span>, customer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户来源</span></span><br><span class="line">        List&lt;Dictionary&gt; sourceList = dictionaryService.queryDictionarytByCode(Constants.SOURCE_TYPE);</span><br><span class="line">        <span class="comment">// 客户所属行业</span></span><br><span class="line">        List&lt;Dictionary&gt; industryList = dictionaryService.queryDictionarytByCode(Constants.INDUSTRY_TYPE);</span><br><span class="line">        <span class="comment">// 客户级别</span></span><br><span class="line">        List&lt;Dictionary&gt; levelList = dictionaryService.queryDictionarytByCode(Constants.LEVEL_TYPE);</span><br><span class="line">        <span class="comment">// 保存数据至Model</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;sourceList&quot;</span>, sourceList);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;industryList&quot;</span>, industryList);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;levelList&quot;</span>, levelList);</span><br><span class="line"></span><br><span class="line">        System.out.println(sourceList);</span><br><span class="line">        System.out.println(customer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;customer_update&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在customer_update页面填写数据后提交至该updateCustomer方法，其路径为&#x2F; update。</p><p>注意事项：</p><ol><li>请在updateCustomer方法上使用@RequestMapping注解</li><li>请在updateCustomer方法上使用@ResponseBody注解将返回值以JSON格式返回至AJAX请求</li><li>该方法的返回值为Result</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新客户</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateCustomer</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> customerService.updateCustomer(customer);</span><br><span class="line">    <span class="keyword">if</span> (rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result.setStatus(Constants.OK);</span><br><span class="line">        result.setDescription(<span class="string">&quot;更新客户成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.setStatus(Constants.ERROR);</span><br><span class="line">        result.setDescription(<span class="string">&quot;更新客户失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除客户"><a href="#删除客户" class="headerlink" title="删除客户"></a>删除客户</h3><p>在customer页面点击删除后提交至该deleteCustomer方法，其路径为&#x2F; delete。</p><p>注意事项：</p><ol><li>请在deleteCustomer方法上使用@RequestMapping注解</li><li>请在deleteCustomer方法上使用@ResponseBody注解将返回值以JSON格式返回至AJAX请求</li><li>该方法的返回值为Result</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除客户</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">deleteCustomer</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> customerService.deleteCustomer(id);</span><br><span class="line">    <span class="keyword">if</span> (rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result.setStatus(Constants.OK);</span><br><span class="line">        result.setDescription(<span class="string">&quot;删除客户成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.setStatus(Constants.ERROR);</span><br><span class="line">        result.setDescription(<span class="string">&quot;删除客户失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="统计分析模块"><a href="#统计分析模块" class="headerlink" title="统计分析模块"></a>统计分析模块</h1><p>在完成客户管理模块的基础之上，我们来对客户进行统计分析。</p><h2 id="相关SQL语句"><a href="#相关SQL语句" class="headerlink" title="相关SQL语句"></a>相关SQL语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.item <span class="keyword">AS</span> name, <span class="built_in">COUNT</span>(c.id) <span class="keyword">AS</span> <span class="keyword">value</span></span><br><span class="line"> <span class="keyword">FROM</span> customer <span class="keyword">AS</span> c</span><br><span class="line"> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dictionary <span class="keyword">AS</span> d</span><br><span class="line"> <span class="keyword">ON</span> c.source<span class="operator">=</span>d.id</span><br><span class="line"> <span class="keyword">WHERE</span> c.source <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c.source;</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> d.item <span class="keyword">AS</span> name, <span class="built_in">COUNT</span>(c.id) <span class="keyword">AS</span> <span class="keyword">value</span></span><br><span class="line"> <span class="keyword">FROM</span> customer <span class="keyword">AS</span> c</span><br><span class="line"> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dictionary <span class="keyword">AS</span> d</span><br><span class="line"> <span class="keyword">ON</span> c.industry<span class="operator">=</span>d.id</span><br><span class="line"> <span class="keyword">WHERE</span> c.industry <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c.industry;</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> d.item <span class="keyword">AS</span> name, <span class="built_in">COUNT</span>(c.id) <span class="keyword">AS</span> <span class="keyword">value</span></span><br><span class="line"> <span class="keyword">FROM</span> customer <span class="keyword">AS</span> c</span><br><span class="line"> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dictionary <span class="keyword">AS</span> d</span><br><span class="line"> <span class="keyword">ON</span> c.level<span class="operator">=</span>d.id</span><br><span class="line"> <span class="keyword">WHERE</span> c.level <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c.level;</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><h2 id="AnalysisController"><a href="#AnalysisController" class="headerlink" title="AnalysisController"></a>AnalysisController</h2><p>注意事项：</p><ol><li>请在AnalysisController类上使用@Controller注解</li><li>请在AnalysisController类上使用@RequestMapping注解</li><li>点击页面左侧的”统计分析”会执行AnalysisController中的list方法</li><li>在list方法中跳转至analysis.jsp页面，即return “analysis”</li><li>AnalysisController中的getCustomerProportion()为依据类型查询相关数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;analysisController&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnalysisController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomerService customerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;analysis&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/proportion&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getCustomerProportion</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = customerService.queryCustomerProportionByType(type);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="analysis-jsp"><a href="#analysis-jsp" class="headerlink" title="analysis.jsp"></a>analysis.jsp</h2><p>analysis.jsp页面中核心逻辑为Echarts图标显示；只需在该页面中利用AJAX调用AnalysisController中的getCustomerProportion()方法即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目演示与功能介绍&quot;&gt;&lt;a href=&quot;#项目演示与功能介绍&quot; class=&quot;headerlink&quot; title=&quot;项目演示与功能介绍&quot;&gt;&lt;/a&gt;项目演示与功能介绍&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;注册登录&lt;/li&gt;
&lt;li&gt;用户管理&lt;/li&gt;
&lt;li&gt;权限管理&lt;/li</summary>
      
    
    
    
    <category term="Java开发框架" scheme="https://zhuxuchen.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java" scheme="https://zhuxuchen.github.io/tags/Java/"/>
    
    <category term="SSM" scheme="https://zhuxuchen.github.io/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Java基础篇</title>
    <link href="https://zhuxuchen.github.io/2023-02-23-29894bfaffc2/"/>
    <id>https://zhuxuchen.github.io/2023-02-23-29894bfaffc2/</id>
    <published>2023-02-23T09:21:00.000Z</published>
    <updated>2023-02-25T08:58:08.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><blockquote><p><em><strong>基础篇要点：算法、数据结构、基础设计模式</strong></em></p></blockquote><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述二分查找算法</li><li>能够手写二分查找代码</li><li>能够解答一些变化后的考法</li></ul><p><strong>算法描述</strong></p><ol><li><p>前提：有已排序数组 A（假设已经做好）</p></li><li><p>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</p></li><li><p>获取中间索引 M &#x3D; Floor((L+R) &#x2F;2)</p></li><li><p>中间索引的值  A[M] 与待搜索的值 T 进行比较</p><p>① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引</p><p>② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p><p>③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p></li><li><p>当 L &gt; R 时，表示没有找到，应结束循环</p></li></ol><blockquote><p><em>更形象的描述请参考：binary_search.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = a.length - <span class="number">1</span>, m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[m] == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &gt; t) &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> binarySearch(array, target);</span><br><span class="line">    System.out.println(idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决整数溢出问题</strong></p><p>当 l 和 r 都较大时，<code>l + r</code> 有可能超过整数范围，造成运算错误，解决方法有两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>还有一种是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>其它考法</strong></p><ol><li><p>有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数 </p></li><li><p>使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较</p></li><li><p>在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次</p></li></ol><p>对于前两个题目，记得一个简要判断口诀：奇数二分取中间，偶数二分取中间靠左。对于后一道题目，需要知道公式：</p><p>$$n &#x3D; log_2N &#x3D; log_{10}N&#x2F;log_{10}2$$</p><p>其中 n 为查找次数，N 为元素个数</p><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述冒泡排序算法</li><li>能够手写冒泡排序代码</li><li>了解一些冒泡排序的优化手段</li></ul><p><strong>算法描述</strong></p><ol><li>依次比较数组中相邻两个元素大小，若 a[j] &gt; a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后</li><li>重复以上步骤，直到整个数组有序</li></ol><blockquote><p><em>更形象的描述请参考：bubble_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 一轮冒泡</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否发生了交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span> - j; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + j + <span class="string">&quot;轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化点1：每经过一轮冒泡，内层循环就可以减少一次</li><li>优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环</li></ul><p><strong>进一步优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble_v2</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示最后一次交换索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = last;</span><br><span class="line">        System.out.println(<span class="string">&quot;第轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为零，表示整个数组有序，直接退出外层循环即可</li></ul><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述选择排序算法</li><li>能够比较选择排序与冒泡排序</li><li>理解非稳定排序与稳定排序</li></ul><p><strong>算法描述</strong></p><ol><li><p>将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集</p></li><li><p>重复以上步骤，直到整个数组有序</p></li></ol><blockquote><p><em>更形象的描述请参考：selection_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selection</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// i 代表每轮选择最小元素要交换到的目标索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> i; <span class="comment">// 代表最小元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s] &gt; a[j]) &#123; <span class="comment">// j 元素比 s 元素还要小, 更新 s</span></span><br><span class="line">                s = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            swap(a, s, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化点：为减少交换次数，每一轮可以先找最小的索引，在每轮最后再交换元素</li></ul><p><strong>与冒泡排序比较</strong></p><ol><li><p>二者平均时间复杂度都是 $O(n^2)$</p></li><li><p>选择排序一般要快于冒泡，因为其交换次数少</p></li><li><p>但如果集合有序度高，冒泡优于选择</p></li><li><p>冒泡属于稳定排序算法，而选择属于不稳定排序</p><ul><li>稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序</li><li>不稳定排序则反之</li></ul></li></ol><p><strong>稳定排序与不稳定排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=================不稳定================&quot;</span>);</span><br><span class="line">Card[] cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=================稳定=================&quot;</span>);</span><br><span class="line">cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br></pre></td></tr></table></figure><p>都是先按照花色排序（♠♥♣♦），再按照数字排序（AKQJ…）</p><ul><li><p>不稳定排序算法按数字排序时，会打乱原本同值的花色顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♥2], [♠2]]</span><br></pre></td></tr></table></figure><p>原来 ♠2 在前 ♥2 在后，按数字再排后，他俩的位置变了</p></li><li><p>稳定排序算法按数字排序时，会保留原本同值的花色顺序，如下所示 ♠2 与 ♥2 的相对位置不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♠2], [♥2]]</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述插入排序算法</li><li>能够比较插入排序与选择排序</li></ul><p><strong>算法描述</strong></p><ol><li><p>将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）</p></li><li><p>重复以上步骤，直到整个数组有序</p></li></ol><blockquote><p><em>更形象的描述请参考：insertion_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了代码与希尔排序一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[j - <span class="number">1</span>]) &#123; <span class="comment">// j-1 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = t;</span><br><span class="line">        System.out.println(Arrays.toString(a) + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与选择排序比较</strong></p><ol><li><p>二者平均时间复杂度都是 $O(n^2)$</p></li><li><p>大部分情况下，插入都略优于选择</p></li><li><p>有序集合插入的时间复杂度为 $O(n)$</p></li><li><p>插入属于稳定排序算法，而选择属于不稳定排序</p></li></ol><p><strong>提示</strong></p><blockquote><p><em>插入排序通常被同学们所轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序</em></p></blockquote><h2 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述希尔排序算法</li></ul><p><strong>算法描述</strong></p><ol><li><p>首先选取一个间隙序列，如 (n&#x2F;2，n&#x2F;4 … 1)，n 为数组长度</p></li><li><p>每一轮将间隙相等的元素视为一组，对组内元素进行插入排序，目的有二</p><p>① 少量元素插入排序速度很快</p><p>② 让组内值较大的元素更快地移动到后方</p></li><li><p>当间隙逐渐减少，直至为 1 时，即可完成排序</p></li></ol><blockquote><p><em>更形象的描述请参考：shell_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shell</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap) &#123;</span><br><span class="line">                <span class="comment">// 每次与上一个间隙为 gap 的元素进行插入排序</span></span><br><span class="line">                <span class="keyword">if</span> (t &lt; a[j - gap]) &#123; <span class="comment">// j-gap 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                    a[j] = a[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = t;</span><br><span class="line">            System.out.println(Arrays.toString(a) + <span class="string">&quot; gap:&quot;</span> + gap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></li></ul><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述快速排序算法</li><li>掌握手写单边循环、双边循环代码之一</li><li>能够说明快排特点</li><li>了解洛穆托与霍尔两种分区方案的性能比较</li></ul><p><strong>算法描述</strong></p><ol><li>每一轮排序选择一个基准点（pivot）进行分区<ol><li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li><li>当分区完成时，基准点元素的位置就是其最终位置</li></ol></li><li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li><li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li></ol><blockquote><p><em>更形象的描述请参考：quick_sort.html</em></p></blockquote><p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p><ol><li><p>选择最右元素作为基准点元素</p></li><li><p>j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换</p></li><li><p>i 指针维护小于基准点元素的边界，也是每次交换的目标索引</p></li><li><p>最后基准点与 i 交换，i 即为分区位置</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h); <span class="comment">// p 索引值</span></span><br><span class="line">    quick(a, l, p - <span class="number">1</span>); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">    quick(a, p + <span class="number">1</span>, h); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[h]; <span class="comment">// 基准点元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; h; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; pv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != h) &#123;</span><br><span class="line">        swap(a, h, i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; i=&quot;</span> + i);</span><br><span class="line">    <span class="comment">// 返回值代表了基准点元素所在的正确索引，用它确定下一轮分区的边界</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p><ol><li>选择最左元素作为基准点元素</li><li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li><li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li></ol><p>要点</p><ol><li><p>基准点在左边，并且要先 j 后 i</p></li><li><p>while( <strong>i</strong> **&lt; j** &amp;&amp; a[j] &gt; pv ) j– </p></li><li><p>while ( <strong>i</strong> <strong>&lt; j</strong> &amp;&amp; a[i] <strong>&lt;&#x3D;</strong> pv ) i++</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h);</span><br><span class="line">    quick(a, l, p - <span class="number">1</span>);</span><br><span class="line">    quick(a, p + <span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// j 从右找小的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pv) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i 从左找大的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pv) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, l, j);</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; j=&quot;</span> + j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快排特点</strong></p><ol><li><p>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$</p></li><li><p>数据量较大时，优势非常明显</p></li><li><p>属于不稳定排序</p></li></ol><p><strong>洛穆托分区方案 vs 霍尔分区方案</strong></p><ul><li>霍尔的移动次数平均来讲比洛穆托少3倍</li><li><a href="https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto">https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto</a></li></ul><blockquote><p><em><strong>补充代码说明</strong></em></p><ul><li>day01.sort.QuickSort3 演示了空穴法改进的双边快排，比较次数更少</li><li>day01.sort.QuickSortHoare 演示了霍尔分区的实现</li><li>day01.sort.LomutoVsHoare 对四种分区实现的移动次数比较</li></ul></blockquote><h2 id="7-ArrayList"><a href="#7-ArrayList" class="headerlink" title="7. ArrayList"></a>7. ArrayList</h2><p><strong>要求</strong></p><ul><li>掌握 ArrayList 扩容规则</li></ul><p><strong>扩容规则</strong></p><ol><li><p>ArrayList() 会使用长度为零的数组</p></li><li><p>ArrayList(int initialCapacity) 会使用指定容量的数组</p></li><li><p>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</p></li><li><p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p></li><li><p>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</p></li></ol><p>其中第 4 点必须知道，其它几点视个人情况而定</p><p><strong>提示</strong></p><ul><li>测试代码见 <code>day01.list.TestArrayList</code> ，这里不再列出</li><li>要<strong>注意</strong>的是，示例中用反射方式来更直观地反映 ArrayList 的扩容特征，但从 JDK 9 由于模块化的影响，对反射做了较多限制，需要在运行测试代码时添加 VM 参数 <code>--add-opens java.base/java.util=ALL-UNNAMED</code> 方能运行通过，后面的例子都有相同问题</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day01.list.TestArrayList#arrayListGrowRule 演示了 add(Object) 方法的扩容规则，输入参数 n 代表打印多少次扩容后的数组长度</li></ul></blockquote><h2 id="8-Iterator"><a href="#8-Iterator" class="headerlink" title="8. Iterator"></a>8. Iterator</h2><p><strong>要求</strong></p><ul><li>掌握什么是 Fail-Fast、什么是 Fail-Safe</li></ul><p>Fail-Fast 与 Fail-Safe</p><ul><li><p>ArrayList 是 fail-fast 的典型代表，遍历的同时不能修改，尽快失败</p></li><li><p>CopyOnWriteArrayList 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离</p></li></ul><p><strong>提示</strong></p><ul><li>测试代码见 <code>day01.list.FailFastVsFailSafe</code>，这里不再列出</li></ul><h2 id="9-LinkedList"><a href="#9-LinkedList" class="headerlink" title="9. LinkedList"></a>9. LinkedList</h2><p><strong>要求</strong></p><ul><li>能够说清楚 LinkedList 对比 ArrayList 的区别，并重视纠正部分错误的认知</li></ul><p><strong>LinkedList</strong></p><ol><li>基于双向链表，无需连续内存</li><li>随机访问慢（要沿着链表遍历）</li><li>头尾插入删除性能高</li><li>占用内存多</li></ol><p><strong>ArrayList</strong></p><ol><li>基于数组，需要连续内存</li><li>随机访问快（指根据下标访问）</li><li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li><li>可以利用 cpu 缓存，局部性原理</li></ol><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day01.list.ArrayListVsLinkedList#randomAccess 对比随机访问性能</li><li>day01.list.ArrayListVsLinkedList#addMiddle 对比向中间插入性能</li><li>day01.list.ArrayListVsLinkedList#addFirst 对比头部插入性能</li><li>day01.list.ArrayListVsLinkedList#addLast 对比尾部插入性能</li><li>day01.list.ArrayListVsLinkedList#linkedListSize 打印一个 LinkedList 占用内存</li><li>day01.list.ArrayListVsLinkedList#arrayListSize 打印一个 ArrayList 占用内存</li></ul></blockquote><h2 id="10-HashMap"><a href="#10-HashMap" class="headerlink" title="10. HashMap"></a>10. HashMap</h2><p><strong>要求</strong></p><ul><li>掌握 HashMap 的基本数据结构</li><li>掌握树化</li><li>理解索引计算方法、二次 hash 的意义、容量对索引计算的影响</li><li>掌握 put 流程、扩容、扩容因子</li><li>理解并发使用 HashMap 可能导致的问题</li><li>理解 key 的设计</li></ul><h3 id="1）基本数据结构"><a href="#1）基本数据结构" class="headerlink" title="1）基本数据结构"></a>1）基本数据结构</h3><ul><li>1.7 数组 + 链表</li><li>1.8 数组 + （链表 | 红黑树）</li></ul><blockquote><p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure></blockquote><h3 id="2）树化与退化"><a href="#2）树化与退化" class="headerlink" title="2）树化与退化"></a>2）树化与退化</h3><p><strong>树化意义</strong></p><ul><li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</li><li>hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li><li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li></ul><p><strong>树化规则</strong></p><ul><li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li></ul><p><strong>退化规则</strong></p><ul><li>情况1：在扩容时如果拆分树时，树元素个数 &lt;&#x3D; 6 则会退化链表</li><li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li></ul><h3 id="3）索引计算"><a href="#3）索引计算" class="headerlink" title="3）索引计算"></a>3）索引计算</h3><p><strong>索引计算方法</strong></p><ul><li>首先，计算对象的 hashCode()</li><li>再进行调用 HashMap 的 hash() 方法进行二次哈希<ul><li>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li></ul></li><li>最后 &amp; (capacity – 1) 得到索引</li></ul><p><strong>数组容量为何是 2 的 n 次幂</strong></p><ol><li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li><li>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li></ol><p><strong>注意</strong></p><ul><li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li><li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable</li></ul><h3 id="4）put-与扩容"><a href="#4）put-与扩容" class="headerlink" title="4）put 与扩容"></a>4）put 与扩容</h3><p><strong>put 流程</strong></p><ol><li>HashMap 是懒惰创建数组的，首次使用才创建数组</li><li>计算索引（桶下标）</li><li>如果桶下标还没人占用，创建 Node 占位返回</li><li>如果桶下标已经有人占用<ol><li>已经是 TreeNode 走红黑树的添加或更新逻辑</li><li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li></ol></li><li>返回前检查容量是否超过阈值，一旦超过进行扩容</li></ol><p><strong>1.7 与 1.8 的区别</strong></p><ol><li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p></li><li><p>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</p></li><li><p>1.8 在扩容计算 Node 索引时，会优化</p></li></ol><p><strong>扩容（加载）因子为何默认是 0.75f</strong></p><ol><li>在空间占用与查询时间之间取得较好的权衡</li><li>大于这个值，空间节省了，但链表就会比较长影响性能</li><li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li></ol><h3 id="5）并发问题"><a href="#5）并发问题" class="headerlink" title="5）并发问题"></a>5）并发问题</h3><p><strong>扩容死链（1.7 会存在）</strong></p><p>1.7 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>e 和 next 都是局部变量，用来指向当前节点和下一个节点</li><li>线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移</li></ul><p><img src="/2023-02-23-29894bfaffc2/image-20210831084325075.png" alt="image-20210831084325075"></p><ul><li>线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移</li></ul><p><img src="/2023-02-23-29894bfaffc2/image-20210831084723383.png" alt="image-20210831084723383"></p><ul><li>第一次循环<ul><li>循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b</li><li>e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）</li><li>当循环结束是 e 会指向 next 也就是 b 节点</li></ul></li></ul><p><img src="/2023-02-23-29894bfaffc2/image-20210831084855348.png" alt="image-20210831084855348"></p><ul><li>第二次循环<ul><li>next 指向了节点 a</li><li>e 头插节点 b</li><li>当循环结束时，e 指向 next 也就是节点 a</li></ul></li></ul><p><img src="/2023-02-23-29894bfaffc2/image-20210831085329449.png" alt="image-20210831085329449"></p><ul><li>第三次循环<ul><li>next 指向了 null</li><li>e 头插节点 a，<strong>a 的 next 指向了 b</strong>（之前 a.next 一直是 null），b 的 next 指向 a，死链已成</li><li>当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出</li></ul></li></ul><p><img src="/2023-02-23-29894bfaffc2/image-20210831085543224.png" alt="image-20210831085543224"></p><p><strong>数据错乱（1.7，1.8 都会存在）</strong></p><ul><li>代码参考 <code>day01.map.HashMapMissData</code>，具体调试步骤参考视频</li></ul><blockquote><p><em><strong>补充代码说明</strong></em></p><ul><li>day01.map.HashMapDistribution 演示 map 中链表长度符合泊松分布</li><li>day01.map.DistributionAffectedByCapacity 演示容量及 hashCode 取值对分布的影响<ul><li>day01.map.DistributionAffectedByCapacity#hashtableGrowRule 演示了 Hashtable 的扩容规律</li><li>day01.sort.Utils#randomArray 如果 hashCode 足够随机，容量是否是 2 的 n 次幂影响不大</li><li>day01.sort.Utils#lowSameArray 如果 hashCode 低位一样的多，容量是 2 的 n 次幂会导致分布不均匀</li><li>day01.sort.Utils#evenArray 如果 hashCode 偶数的多，容量是 2 的 n 次幂会导致分布不均匀</li><li>由此得出对于容量是 2 的 n 次幂的设计来讲，二次 hash 非常重要</li></ul></li><li>day01.map.HashMapVsHashtable 演示了对于同样数量的单词字符串放入 HashMap 和 Hashtable 分布上的区别</li></ul></blockquote><h3 id="6）key-的设计"><a href="#6）key-的设计" class="headerlink" title="6）key 的设计"></a>6）key 的设计</h3><p><strong>key 的设计要求</strong></p><ol><li>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</li><li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</li><li>key 的 hashCode 应该有良好的散列性</li></ol><p>如果 key 可变，例如修改了 age 会导致再次查询时查询不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapMutableKey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;Student, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        map.put(stu, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line"></span><br><span class="line">        stu.age = <span class="number">19</span>;</span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">            <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String 对象的 hashCode() 设计</strong></p><ul><li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li><li>字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1 </li><li>散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$</li><li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 <ul><li>即 $32 ∗h -h $</li><li>即 $2^5  ∗h -h$</li><li>即 $h≪5  -h$</li></ul></li></ul><h2 id="11-单例模式"><a href="#11-单例模式" class="headerlink" title="11. 单例模式"></a>11. 单例模式</h2><p><strong>要求</strong></p><ul><li>掌握五种单例模式的实现方式</li><li>理解为何 DCL 实现时要使用 volatile 修饰静态变量</li><li>了解 jdk 中用到单例的场景</li></ul><p><strong>饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例对象不能重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法抛出异常是防止反射破坏单例</li><li><code>readResolve()</code> 是防止反序列化破坏单例</li></ul><p><strong>枚举饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举饿汉式能天然防止反射、反序列化破坏单例</li></ul><p><strong>懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton3()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Singleton3.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其实只有首次创建单例对象时才需要同步，但该代码实际上每次调用都会同步</li><li>因此有了下面的双检锁改进</li></ul><p><strong>双检锁懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton4</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 可见性，有序性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为何必须加 volatile：</p><ul><li><code>INSTANCE = new Singleton4()</code> 不是原子的，分成 3 步：创建对象、调用构造、给静态变量赋值，其中后两步可能被指令重排序优化，变成先赋值、再调用构造</li><li>如果线程1 先执行了赋值，线程2 执行到第一个 <code>INSTANCE == null</code> 时发现 INSTANCE 已经不为 null，此时就会返回一个未完全构造的对象</li></ul><p><strong>内部类懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton5()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">Singleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>避免了双检锁的缺点</li></ul><p><strong>JDK 中单例的体现</strong></p><ul><li>Runtime 体现了饿汉式单例</li><li>Console 体现了双检锁懒汉式单例</li><li>Collections 中的 EmptyNavigableSet 内部类懒汉式单例</li><li>ReverseComparator.REVERSE_ORDER 内部类懒汉式单例</li><li>Comparators.NaturalOrderComparator.INSTANCE 枚举饿汉式单例</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/a&gt;基础篇&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;基础篇要点：算法、数据结构、基础设计模式&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="面试题" scheme="https://zhuxuchen.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://zhuxuchen.github.io/tags/Java/"/>
    
    <category term="面试题" scheme="https://zhuxuchen.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java并发篇</title>
    <link href="https://zhuxuchen.github.io/2023-02-23-8faeca15efaf/"/>
    <id>https://zhuxuchen.github.io/2023-02-23-8faeca15efaf/</id>
    <published>2023-02-23T08:48:15.000Z</published>
    <updated>2023-02-25T08:58:08.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h1><h2 id="1-线程状态"><a href="#1-线程状态" class="headerlink" title="1. 线程状态"></a>1. 线程状态</h2><p><strong>要求</strong></p><ul><li>掌握 Java 线程六种状态</li><li>掌握 Java 线程状态转换</li><li>能理解五种状态与六种状态两种说法的区别</li></ul><p><strong>六种状态及转换</strong></p><p><img src="/2023-02-23-8faeca15efaf/image-20210831090722658.png" alt="image-20210831090722658"></p><p>分别是</p><ul><li>新建<ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></li><li>可运行<ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></li><li>终结<ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li><li>此时会取消与底层线程关联</li></ul></li><li>阻塞<ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></li><li>等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></li><li>有时限等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></li></ul><blockquote><p><em><strong>其它情况（只需了解）</strong></em></p><ul><li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li><li>park，unpark 等方法也可以让线程等待和唤醒</li></ul></blockquote><p><strong>五种状态</strong></p><p>五种状态的说法来自于操作系统层面的划分</p><p><img src="/2023-02-23-8faeca15efaf/image-20210831092652602.png" alt="image-20210831092652602"></p><ul><li>运行态：分到 cpu 时间，能真正执行线程内代码的</li><li>就绪态：有资格分到 cpu 时间，但还未轮到它的</li><li>阻塞态：没资格分到 cpu 时间的<ul><li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li><li>多出了阻塞 I&#x2F;O，指线程在调用阻塞 I&#x2F;O 时，实际活由 I&#x2F;O 设备完成，此时线程无事可做，只能干等</li></ul></li><li>新建与终结态：与 java 中同名状态类似，不再啰嗦</li></ul><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h2><p><strong>要求</strong></p><ul><li>掌握线程池的 7 大核心参数</li></ul><p><strong>七大参数</strong></p><ol><li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li><li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol><li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li><li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li><li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li><li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li></ol></li></ol><p><img src="/2023-02-23-8faeca15efaf/image-20210831093204388.png" alt="image-20210831093204388"></p><blockquote><p><em><strong>代码说明</strong></em></p><p>day02.TestThreadPoolExecutor 以较为形象的方式演示了线程池的核心组成</p></blockquote><h2 id="3-wait-vs-sleep"><a href="#3-wait-vs-sleep" class="headerlink" title="3. wait vs sleep"></a>3. wait vs sleep</h2><p><strong>要求</strong></p><ul><li>能够说出二者区别</li></ul><p><strong>一个共同点，三个不同点</strong></p><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li><p>方法归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同（重点）</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul><h2 id="4-lock-vs-synchronized"><a href="#4-lock-vs-synchronized" class="headerlink" title="4. lock vs synchronized"></a>4. lock vs synchronized</h2><p><strong>要求</strong></p><ul><li>掌握 lock 与 synchronized 的区别</li><li>理解 ReentrantLock 的公平、非公平锁</li><li>理解 ReentrantLock 中的条件变量</li></ul><p><strong>三个层面</strong></p><p>不同点</p><ul><li>语法层面<ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li></ul></li><li>功能层面<ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul></li><li>性能层面<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul></li></ul><p><strong>公平锁</strong></p><ul><li>公平锁的公平体现<ul><li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li><li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li><li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li></ul></li><li>公平锁会降低吞吐量，一般不用</li></ul><p><strong>条件变量</strong></p><ul><li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</li><li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.TestReentrantLock 用较为形象的方式演示 ReentrantLock 的内部结构</li></ul></blockquote><h2 id="5-volatile"><a href="#5-volatile" class="headerlink" title="5. volatile"></a>5. volatile</h2><p><strong>要求</strong></p><ul><li>掌握线程安全要考虑的三个问题</li><li>掌握 volatile 能解决哪些问题</li></ul><p><strong>原子性</strong></p><ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li></ul><p><strong>可见性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li></ul><p><strong>有序性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li><li>注意：<ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.threadsafe.AddAndSubtract 演示原子性</li><li>day02.threadsafe.ForeverLoop 演示可见性<ul><li>注意：本例经实践检验是编译器优化导致的可见性问题</li></ul></li><li>day02.threadsafe.Reordering 演示有序性<ul><li>需要打成 jar 包后测试</li></ul></li><li>请同时参考视频讲解</li></ul></blockquote><h2 id="6-悲观锁-vs-乐观锁"><a href="#6-悲观锁-vs-乐观锁" class="headerlink" title="6. 悲观锁 vs 乐观锁"></a>6. 悲观锁 vs 乐观锁</h2><p><strong>要求</strong></p><ul><li>掌握悲观锁和乐观锁的区别</li></ul><p><strong>对比悲观锁与乐观锁</strong></p><ul><li><p>悲观锁的代表是 synchronized 和 Lock 锁</p><ul><li>其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】</li><li>线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li><li>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会</li></ul></li><li><p>乐观锁的代表是 AtomicInteger，使用 cas 来保证原子性</p><ul><li>其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】</li><li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li><li>它需要多核 cpu 支持，且线程数不应超过 cpu 核数</li></ul></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.SyncVsCas 演示了分别使用乐观锁和悲观锁解决原子赋值</li><li>请同时参考视频讲解</li></ul></blockquote><h2 id="7-Hashtable-vs-ConcurrentHashMap"><a href="#7-Hashtable-vs-ConcurrentHashMap" class="headerlink" title="7. Hashtable vs ConcurrentHashMap"></a>7. Hashtable vs ConcurrentHashMap</h2><p><strong>要求</strong></p><ul><li>掌握 Hashtable 与 ConcurrentHashMap 的区别</li><li>掌握 ConcurrentHashMap 在不同版本的实现区别</li></ul><blockquote><p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure></blockquote><p><strong>Hashtable 对比 ConcurrentHashMap</strong></p><ul><li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li><li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li><li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li></ul><p><strong>ConcurrentHashMap 1.7</strong></p><ul><li>数据结构：<code>Segment(大数组) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li><li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment 数组不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了</li><li>索引计算<ul><li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li><li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li></ul></li><li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍</li><li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li></ul><p><strong>ConcurrentHashMap 1.8</strong></p><ul><li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li><li>并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容</li><li>扩容条件：Node 数组满 3&#x2F;4 时就会扩容</li><li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode</li><li>扩容时并发 get<ul><li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li><li>如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变</li><li>如果链表最后几个元素扩容后索引不变，则节点无需复制</li></ul></li><li>扩容时并发 put<ul><li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li><li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li><li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li></ul></li><li>与 1.7 相比是懒惰初始化</li><li>capacity 代表预估的元素个数，capacity &#x2F; factory 来计算出初始数组大小，需要贴近 $2^n$ </li><li>loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3&#x2F;4</li><li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li></ul><h2 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8. ThreadLocal"></a>8. ThreadLocal</h2><p><strong>要求</strong></p><ul><li>掌握 ThreadLocal 的作用与原理</li><li>掌握 ThreadLocal 的内存释放时机</li></ul><p><strong>作用</strong></p><ul><li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ul><p><strong>原理</strong></p><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p>ThreadLocalMap 的一些特点</p><ul><li>key 的 hash 值统一分配</li><li>初始容量 16，扩容因子 2&#x2F;3，扩容容量翻倍</li><li>key 索引冲突后用开放寻址法解决冲突</li></ul><p><strong>弱引用 key</strong></p><p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p><ul><li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li></ul><p><strong>内存释放时机</strong></p><ul><li>被动 GC 释放 key<ul><li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li></ul></li><li>懒惰被动释放 value<ul><li>get key 时，发现是 null key，则释放其 value 内存</li><li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li></ul></li><li>主动 remove 释放 key，value<ul><li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li><li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发篇&quot;&gt;&lt;a href=&quot;#并发篇&quot; class=&quot;headerlink&quot; title=&quot;并发篇&quot;&gt;&lt;/a&gt;并发篇&lt;/h1&gt;&lt;h2 id=&quot;1-线程状态&quot;&gt;&lt;a href=&quot;#1-线程状态&quot; class=&quot;headerlink&quot; title=&quot;1. 线程状态&quot;&gt;</summary>
      
    
    
    
    <category term="面试题" scheme="https://zhuxuchen.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://zhuxuchen.github.io/tags/Java/"/>
    
    <category term="面试题" scheme="https://zhuxuchen.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
